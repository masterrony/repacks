webpackHotUpdate("main",{

/***/ "./node_modules/react-hook-form/dist/index.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/react-hook-form/dist/index.esm.js ***!
  \********************************************************/
/*! exports provided: Controller, FormProvider, appendErrors, get, transformToNestObject, useFieldArray, useForm, useFormContext, useWatch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Controller\", function() { return Controller; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FormProvider\", function() { return FormProvider; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"appendErrors\", function() { return appendErrors; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"get\", function() { return get; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformToNestObject\", function() { return transformToNestObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useFieldArray\", function() { return useFieldArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useForm\", function() { return useForm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useFormContext\", function() { return useFormContext; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"useWatch\", function() { return useWatch; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar isHTMLElement = (value) => value instanceof HTMLElement;\n\nconst EVENTS = {\r\n    BLUR: 'blur',\r\n    CHANGE: 'change',\r\n    INPUT: 'input',\r\n};\r\nconst VALIDATION_MODE = {\r\n    onBlur: 'onBlur',\r\n    onChange: 'onChange',\r\n    onSubmit: 'onSubmit',\r\n    all: 'all',\r\n};\r\nconst VALUE = 'value';\r\nconst SELECT = 'select';\r\nconst UNDEFINED = 'undefined';\r\nconst INPUT_VALIDATION_RULES = {\r\n    max: 'max',\r\n    min: 'min',\r\n    maxLength: 'maxLength',\r\n    minLength: 'minLength',\r\n    pattern: 'pattern',\r\n    required: 'required',\r\n    validate: 'validate',\r\n};\n\nfunction attachEventListeners({ ref }, shouldAttachChangeEvent, handleChange) {\r\n    if (isHTMLElement(ref) && handleChange) {\r\n        ref.addEventListener(shouldAttachChangeEvent ? EVENTS.CHANGE : EVENTS.INPUT, handleChange);\r\n        ref.addEventListener(EVENTS.BLUR, handleChange);\r\n    }\r\n}\n\nvar isNullOrUndefined = (value) => value == null;\n\nvar isArray = (value) => Array.isArray(value);\n\nconst isObjectType = (value) => typeof value === 'object';\r\nvar isObject = (value) => !isNullOrUndefined(value) && !isArray(value) && isObjectType(value);\n\nvar isKey = (value) => !isArray(value) &&\r\n    (/^\\w*$/.test(value) ||\r\n        !/\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/.test(value));\n\nvar stringToPath = (input) => {\r\n    const result = [];\r\n    input.replace(/[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g, (match, mathNumber, mathQuote, originalString) => {\r\n        result.push(mathQuote\r\n            ? originalString.replace(/\\\\(\\\\)?/g, '$1')\r\n            : mathNumber || match);\r\n    });\r\n    return result;\r\n};\n\nfunction set(object, path, value) {\r\n    let index = -1;\r\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\r\n    const length = tempPath.length;\r\n    const lastIndex = length - 1;\r\n    while (++index < length) {\r\n        const key = tempPath[index];\r\n        let newValue = value;\r\n        if (index !== lastIndex) {\r\n            const objValue = object[key];\r\n            newValue =\r\n                isObject(objValue) || isArray(objValue)\r\n                    ? objValue\r\n                    : !isNaN(+tempPath[index + 1])\r\n                        ? []\r\n                        : {};\r\n        }\r\n        object[key] = newValue;\r\n        object = object[key];\r\n    }\r\n    return object;\r\n}\n\nvar transformToNestObject = (data) => Object.entries(data).reduce((previous, [key, value]) => {\r\n    if (!isKey(key)) {\r\n        set(previous, key, value);\r\n        return previous;\r\n    }\r\n    return Object.assign(Object.assign({}, previous), { [key]: value });\r\n}, {});\n\nvar isUndefined = (val) => val === undefined;\n\nvar unique = (value) => value.filter(Boolean);\n\nvar get = (obj, path, defaultValue) => {\r\n    const result = unique(path.split(/[,[\\].]+?/)).reduce((result, key) => (isNullOrUndefined(result) ? result : result[key]), obj);\r\n    return isUndefined(result) || result === obj\r\n        ? isUndefined(obj[path])\r\n            ? defaultValue\r\n            : obj[path]\r\n        : result;\r\n};\n\nvar focusOnErrorField = (fields, fieldErrors) => {\r\n    for (const key in fields) {\r\n        if (get(fieldErrors, key)) {\r\n            const field = fields[key];\r\n            if (field) {\r\n                if (field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n                else if (field.options) {\r\n                    field.options[0].ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n};\n\nvar removeAllEventListeners = (ref, validateWithStateUpdate) => {\r\n    if (isHTMLElement(ref) && ref.removeEventListener) {\r\n        ref.removeEventListener(EVENTS.INPUT, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.CHANGE, validateWithStateUpdate);\r\n        ref.removeEventListener(EVENTS.BLUR, validateWithStateUpdate);\r\n    }\r\n};\n\nconst defaultReturn = {\r\n    isValid: false,\r\n    value: '',\r\n};\r\nvar getRadioValue = (options) => isArray(options)\r\n    ? options.reduce((previous, option) => option && option.ref.checked\r\n        ? {\r\n            isValid: true,\r\n            value: option.ref.value,\r\n        }\r\n        : previous, defaultReturn)\r\n    : defaultReturn;\n\nvar getMultipleSelectValue = (options) => [...options]\r\n    .filter(({ selected }) => selected)\r\n    .map(({ value }) => value);\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isMultipleSelect = (element) => element.type === `${SELECT}-multiple`;\n\nconst defaultResult = {\r\n    value: false,\r\n    isValid: false,\r\n};\r\nconst validResult = { value: true, isValid: true };\r\nvar getCheckboxValue = (options) => {\r\n    if (isArray(options)) {\r\n        if (options.length > 1) {\r\n            const values = options\r\n                .filter((option) => option && option.ref.checked)\r\n                .map(({ ref: { value } }) => value);\r\n            return { value: values, isValid: !!values.length };\r\n        }\r\n        const { checked, value, attributes } = options[0].ref;\r\n        return checked\r\n            ? attributes && !isUndefined(attributes.value)\r\n                ? isUndefined(value) || value === ''\r\n                    ? validResult\r\n                    : { value: value, isValid: true }\r\n                : validResult\r\n            : defaultResult;\r\n    }\r\n    return defaultResult;\r\n};\n\nfunction getFieldValue(fieldsRef, name, unmountFieldsStateRef) {\r\n    const field = fieldsRef.current[name];\r\n    if (field) {\r\n        const { ref: { value }, ref, } = field;\r\n        if (isFileInput(ref)) {\r\n            return ref.files;\r\n        }\r\n        if (isRadioInput(ref)) {\r\n            return getRadioValue(field.options).value;\r\n        }\r\n        if (isMultipleSelect(ref)) {\r\n            return getMultipleSelectValue(ref.options);\r\n        }\r\n        if (isCheckBoxInput(ref)) {\r\n            return getCheckboxValue(field.options).value;\r\n        }\r\n        return value;\r\n    }\r\n    if (unmountFieldsStateRef) {\r\n        return unmountFieldsStateRef.current[name];\r\n    }\r\n}\n\nfunction isDetached(element) {\r\n    if (!element) {\r\n        return true;\r\n    }\r\n    if (!(element instanceof HTMLElement) ||\r\n        element.nodeType === Node.DOCUMENT_NODE) {\r\n        return false;\r\n    }\r\n    return isDetached(element.parentNode);\r\n}\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nfunction baseGet(object, updatePath) {\r\n    const path = updatePath.slice(0, -1);\r\n    const length = path.length;\r\n    let index = 0;\r\n    while (index < length) {\r\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\r\n    }\r\n    return object;\r\n}\r\nfunction unset(object, path) {\r\n    const updatePath = isKey(path) ? [path] : stringToPath(path);\r\n    const childObject = updatePath.length == 1 ? object : baseGet(object, updatePath);\r\n    const key = updatePath[updatePath.length - 1];\r\n    let previousObjRef = undefined;\r\n    if (childObject) {\r\n        delete childObject[key];\r\n    }\r\n    for (let k = 0; k < updatePath.slice(0, -1).length; k++) {\r\n        let index = -1;\r\n        let objectRef = undefined;\r\n        const currentPaths = updatePath.slice(0, -(k + 1));\r\n        const currentPathsLength = currentPaths.length - 1;\r\n        if (k > 0) {\r\n            previousObjRef = object;\r\n        }\r\n        while (++index < currentPaths.length) {\r\n            const item = currentPaths[index];\r\n            objectRef = objectRef ? objectRef[item] : object[item];\r\n            if (currentPathsLength === index &&\r\n                ((isObject(objectRef) && isEmptyObject(objectRef)) ||\r\n                    (isArray(objectRef) &&\r\n                        !objectRef.filter((data) => isObject(data) && !isEmptyObject(data))\r\n                            .length))) {\r\n                previousObjRef ? delete previousObjRef[item] : delete object[item];\r\n            }\r\n            previousObjRef = objectRef;\r\n        }\r\n    }\r\n    return object;\r\n}\n\nconst isSameRef = (fieldValue, ref) => fieldValue && fieldValue.ref === ref;\r\nfunction findRemovedFieldAndRemoveListener(fieldsRef, handleChange, field, unmountFieldsStateRef, shouldUnregister, forceDelete) {\r\n    const { ref, ref: { name, type }, mutationWatcher, } = field;\r\n    const fieldRef = fieldsRef.current[name];\r\n    if (!shouldUnregister) {\r\n        const value = getFieldValue(fieldsRef, name, unmountFieldsStateRef);\r\n        if (!isUndefined(value)) {\r\n            unmountFieldsStateRef.current[name] = value;\r\n        }\r\n    }\r\n    if (!type) {\r\n        delete fieldsRef.current[name];\r\n        return;\r\n    }\r\n    if ((isRadioInput(ref) || isCheckBoxInput(ref)) && fieldRef) {\r\n        const { options } = fieldRef;\r\n        if (isArray(options) && options.length) {\r\n            unique(options).forEach((option, index) => {\r\n                const { ref, mutationWatcher } = option;\r\n                if ((ref && isDetached(ref) && isSameRef(option, ref)) || forceDelete) {\r\n                    removeAllEventListeners(ref, handleChange);\r\n                    if (mutationWatcher) {\r\n                        mutationWatcher.disconnect();\r\n                    }\r\n                    unset(options, `[${index}]`);\r\n                }\r\n            });\r\n            if (options && !unique(options).length) {\r\n                delete fieldsRef.current[name];\r\n            }\r\n        }\r\n        else {\r\n            delete fieldsRef.current[name];\r\n        }\r\n    }\r\n    else if ((isDetached(ref) && isSameRef(fieldRef, ref)) || forceDelete) {\r\n        removeAllEventListeners(ref, handleChange);\r\n        if (mutationWatcher) {\r\n            mutationWatcher.disconnect();\r\n        }\r\n        delete fieldsRef.current[name];\r\n    }\r\n}\n\nvar isString = (value) => typeof value === 'string';\n\nfunction deepMerge(target, source) {\r\n    if (!isObject(target) || !isObject(source)) {\r\n        return source;\r\n    }\r\n    for (const key in source) {\r\n        const targetValue = target[key];\r\n        const sourceValue = source[key];\r\n        if (isObject(targetValue) && isObject(sourceValue)) {\r\n            target[key] = deepMerge(targetValue, sourceValue);\r\n        }\r\n        else {\r\n            target[key] = sourceValue;\r\n        }\r\n    }\r\n    return target;\r\n}\n\nvar getFieldsValues = (fieldsRef, unmountFieldsStateRef, search) => {\r\n    const output = {};\r\n    for (const name in fieldsRef.current) {\r\n        if (isUndefined(search) ||\r\n            (isString(search)\r\n                ? name.startsWith(search)\r\n                : isArray(search) && search.find((data) => name.startsWith(data)))) {\r\n            output[name] = getFieldValue(fieldsRef, name);\r\n        }\r\n    }\r\n    return deepMerge(transformToNestObject((unmountFieldsStateRef || {}).current || {}), transformToNestObject(output));\r\n};\n\nvar isSameError = (error, { type, types = {}, message }) => isObject(error) &&\r\n    error.type === type &&\r\n    error.message === message &&\r\n    Object.keys(error.types || {}).length === Object.keys(types).length &&\r\n    Object.entries(error.types || {}).every(([key, value]) => types[key] === value);\n\nfunction shouldRenderBasedOnError({ errors, name, error, validFields, fieldsWithValidation, }) {\r\n    const isFieldValid = isEmptyObject(error);\r\n    const isFormValid = isEmptyObject(errors);\r\n    const currentFieldError = get(error, name);\r\n    const existFieldError = get(errors, name);\r\n    if (isFieldValid && validFields.has(name)) {\r\n        return false;\r\n    }\r\n    if (isFormValid !== isFieldValid ||\r\n        (!isFormValid && !existFieldError) ||\r\n        (isFieldValid && fieldsWithValidation.has(name) && !validFields.has(name))) {\r\n        return true;\r\n    }\r\n    return currentFieldError && !isSameError(existFieldError, currentFieldError);\r\n}\n\nvar isRegex = (value) => value instanceof RegExp;\n\nconst isValueMessage = (value) => isObject(value) && !isRegex(value);\r\nvar getValueAndMessage = (validationData) => isValueMessage(validationData)\r\n    ? validationData\r\n    : {\r\n        value: validationData,\r\n        message: '',\r\n    };\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nvar isMessage = (value) => isString(value) || (isObject(value) && Object(react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"])(value));\n\nfunction getValidateError(result, ref, type = 'validate') {\r\n    if (isMessage(result) || (isBoolean(result) && !result)) {\r\n        return {\r\n            type,\r\n            message: isMessage(result) ? result : '',\r\n            ref,\r\n        };\r\n    }\r\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => {\r\n    if (validateAllFieldCriteria) {\r\n        const error = errors[name];\r\n        return Object.assign(Object.assign({}, error), { types: Object.assign(Object.assign({}, (error && error.types ? error.types : {})), { [type]: message || true }) });\r\n    }\r\n    return {};\r\n};\n\nvar validateField = async (fieldsRef, validateAllFieldCriteria, { ref, ref: { type, value }, options, required, maxLength, minLength, min, max, pattern, validate, }, unmountFieldsStateRef) => {\r\n    const fields = fieldsRef.current;\r\n    const name = ref.name;\r\n    const error = {};\r\n    const isRadio = isRadioInput(ref);\r\n    const isCheckBox = isCheckBoxInput(ref);\r\n    const isRadioOrCheckbox = isRadio || isCheckBox;\r\n    const isEmpty = value === '';\r\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\r\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\r\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\r\n        error[name] = Object.assign({ type: exceedMax ? maxType : minType, message,\r\n            ref }, (exceedMax\r\n            ? appendErrorsCurry(maxType, message)\r\n            : appendErrorsCurry(minType, message)));\r\n    };\r\n    if (required &&\r\n        ((!isRadio && !isCheckBox && (isEmpty || isNullOrUndefined(value))) ||\r\n            (isBoolean(value) && !value) ||\r\n            (isCheckBox && !getCheckboxValue(options).isValid) ||\r\n            (isRadio && !getRadioValue(options).isValid))) {\r\n        const { value: requiredValue, message: requiredMessage } = isMessage(required)\r\n            ? { value: !!required, message: required }\r\n            : getValueAndMessage(required);\r\n        if (requiredValue) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.required, message: requiredMessage, ref: isRadioOrCheckbox\r\n                    ? (fields[name].options || [])[0].ref\r\n                    : ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.required, requiredMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (!isNullOrUndefined(min) || !isNullOrUndefined(max)) {\r\n        let exceedMax;\r\n        let exceedMin;\r\n        const { value: maxValue, message: maxMessage } = getValueAndMessage(max);\r\n        const { value: minValue, message: minMessage } = getValueAndMessage(min);\r\n        if (type === 'number' || (!type && !isNaN(value))) {\r\n            const valueNumber = ref.valueAsNumber || parseFloat(value);\r\n            if (!isNullOrUndefined(maxValue)) {\r\n                exceedMax = valueNumber > maxValue;\r\n            }\r\n            if (!isNullOrUndefined(minValue)) {\r\n                exceedMin = valueNumber < minValue;\r\n            }\r\n        }\r\n        else {\r\n            const valueDate = ref.valueAsDate || new Date(value);\r\n            if (isString(maxValue)) {\r\n                exceedMax = valueDate > new Date(maxValue);\r\n            }\r\n            if (isString(minValue)) {\r\n                exceedMin = valueDate < new Date(minValue);\r\n            }\r\n        }\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxMessage, minMessage, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (isString(value) && !isEmpty && (maxLength || minLength)) {\r\n        const { value: maxLengthValue, message: maxLengthMessage, } = getValueAndMessage(maxLength);\r\n        const { value: minLengthValue, message: minLengthMessage, } = getValueAndMessage(minLength);\r\n        const inputLength = value.toString().length;\r\n        const exceedMax = !isNullOrUndefined(maxLengthValue) && inputLength > maxLengthValue;\r\n        const exceedMin = !isNullOrUndefined(minLengthValue) && inputLength < minLengthValue;\r\n        if (exceedMax || exceedMin) {\r\n            getMinMaxMessage(!!exceedMax, maxLengthMessage, minLengthMessage);\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (pattern && !isEmpty) {\r\n        const { value: patternValue, message: patternMessage } = getValueAndMessage(pattern);\r\n        if (isRegex(patternValue) && !patternValue.test(value)) {\r\n            error[name] = Object.assign({ type: INPUT_VALIDATION_RULES.pattern, message: patternMessage, ref }, appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, patternMessage));\r\n            if (!validateAllFieldCriteria) {\r\n                return error;\r\n            }\r\n        }\r\n    }\r\n    if (validate) {\r\n        const fieldValue = getFieldValue(fieldsRef, name, unmountFieldsStateRef);\r\n        const validateRef = isRadioOrCheckbox && options ? options[0].ref : ref;\r\n        if (isFunction(validate)) {\r\n            const result = await validate(fieldValue);\r\n            const validateError = getValidateError(result, validateRef);\r\n            if (validateError) {\r\n                error[name] = Object.assign(Object.assign({}, validateError), appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message));\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n        else if (isObject(validate)) {\r\n            let validationResult = {};\r\n            for (const [key, validateFunction] of Object.entries(validate)) {\r\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\r\n                    break;\r\n                }\r\n                const validateResult = await validateFunction(fieldValue);\r\n                const validateError = getValidateError(validateResult, validateRef, key);\r\n                if (validateError) {\r\n                    validationResult = Object.assign(Object.assign({}, validateError), appendErrorsCurry(key, validateError.message));\r\n                    if (validateAllFieldCriteria) {\r\n                        error[name] = validationResult;\r\n                    }\r\n                }\r\n            }\r\n            if (!isEmptyObject(validationResult)) {\r\n                error[name] = Object.assign({ ref: validateRef }, validationResult);\r\n                if (!validateAllFieldCriteria) {\r\n                    return error;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return error;\r\n};\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nconst getPath = (path, values) => {\r\n    const getInnerPath = (value, key, isObject) => {\r\n        const pathWithIndex = isObject ? `${path}.${key}` : `${path}[${key}]`;\r\n        return isPrimitive(value) ? pathWithIndex : getPath(pathWithIndex, value);\r\n    };\r\n    return Object.entries(values)\r\n        .map(([key, value]) => getInnerPath(value, key, isObject(values)))\r\n        .flat(Infinity);\r\n};\n\nvar assignWatchFields = (fieldValues, fieldName, watchFields, inputValue, isSingleField) => {\r\n    let value;\r\n    watchFields.add(fieldName);\r\n    if (isEmptyObject(fieldValues)) {\r\n        value = undefined;\r\n    }\r\n    else {\r\n        value = get(fieldValues, fieldName);\r\n        if (isObject(value) || isArray(value)) {\r\n            getPath(fieldName, value).forEach((name) => watchFields.add(name));\r\n        }\r\n    }\r\n    return isUndefined(value)\r\n        ? isSingleField\r\n            ? inputValue\r\n            : get(inputValue, fieldName)\r\n        : value;\r\n};\n\nvar skipValidation = ({ isOnBlur, isOnChange, isReValidateOnBlur, isReValidateOnChange, isBlurEvent, isSubmitted, isOnAll, }) => {\r\n    if (isOnAll) {\r\n        return false;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnBlur : isOnBlur) {\r\n        return !isBlurEvent;\r\n    }\r\n    else if (isSubmitted ? isReValidateOnChange : isOnChange) {\r\n        return isBlurEvent;\r\n    }\r\n    return true;\r\n};\n\nvar getFieldArrayParentName = (name) => name.substring(0, name.indexOf('['));\n\nfunction deepEqual(object1 = [], object2 = []) {\r\n    const keys1 = Object.keys(object1);\r\n    const keys2 = Object.keys(object2);\r\n    if (keys1.length !== keys2.length) {\r\n        return false;\r\n    }\r\n    for (const key of keys1) {\r\n        const val1 = object1[key];\r\n        const val2 = object2[key];\r\n        if ((isObject(val1) || isArray(val1)) && (isObject(val2) || isArray(val2))\r\n            ? !deepEqual(val1, val2)\r\n            : val1 !== val2) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\n\nconst isMatchFieldArrayName = (name, searchName) => RegExp(`^${searchName}[\\\\d+]`.replace(/\\[/g, '\\\\[').replace(/\\]/g, '\\\\]')).test(name);\r\nvar isNameInFieldArray = (names, name) => [...names].some((current) => isMatchFieldArrayName(name, current));\n\nvar isSelectInput = (element) => element.type === `${SELECT}-one`;\n\nfunction onDomRemove(element, onDetachCallback) {\r\n    const observer = new MutationObserver(() => {\r\n        if (isDetached(element)) {\r\n            observer.disconnect();\r\n            onDetachCallback();\r\n        }\r\n    });\r\n    observer.observe(window.document, {\r\n        childList: true,\r\n        subtree: true,\r\n    });\r\n    return observer;\r\n}\n\nvar modeChecker = (mode) => ({\r\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\r\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\r\n    isOnChange: mode === VALIDATION_MODE.onChange,\r\n    isOnAll: mode === VALIDATION_MODE.all,\r\n});\n\nvar isRadioOrCheckboxFunction = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nconst isWindowUndefined = typeof window === UNDEFINED;\r\nconst isWeb = typeof document !== UNDEFINED &&\r\n    !isWindowUndefined &&\r\n    !isUndefined(window.HTMLElement);\r\nconst isProxyEnabled = isWeb ? 'Proxy' in window : typeof Proxy !== UNDEFINED;\r\nfunction useForm({ mode = VALIDATION_MODE.onSubmit, reValidateMode = VALIDATION_MODE.onChange, resolver, context, defaultValues = {}, shouldFocusError = true, shouldUnregister = true, criteriaMode, } = {}) {\r\n    const fieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const errorsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const touchedFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const fieldArrayDefaultValues = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const dirtyFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const watchFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const watchFieldsHookRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const watchFieldsHookRenderRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const fieldsWithValidationRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const validFieldsRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const isValidRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(true);\r\n    const defaultValuesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(defaultValues);\r\n    const defaultValuesAtRenderRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const isUnMount = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const isWatchAllRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const isSubmittedRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const isDirtyRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const submitCountRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(0);\r\n    const isSubmittingRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(false);\r\n    const handleChangeRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\r\n    const unmountFieldsStateRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const resetFieldArrayFunctionRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({});\r\n    const contextRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(context);\r\n    const resolverRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(resolver);\r\n    const fieldArrayNamesRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(new Set());\r\n    const [, render] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])();\r\n    const modeRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(modeChecker(mode));\r\n    const { current: { isOnSubmit, isOnAll }, } = modeRef;\r\n    const isValidateAllFieldCriteria = criteriaMode === VALIDATION_MODE.all;\r\n    const readFormStateRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])({\r\n        isDirty: !isProxyEnabled,\r\n        dirtyFields: !isProxyEnabled,\r\n        isSubmitted: isOnSubmit,\r\n        submitCount: !isProxyEnabled,\r\n        touched: !isProxyEnabled,\r\n        isSubmitting: !isProxyEnabled,\r\n        isValid: !isProxyEnabled,\r\n    });\r\n    const { current: { isOnBlur: isReValidateOnBlur, isOnChange: isReValidateOnChange }, } = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(modeChecker(reValidateMode));\r\n    contextRef.current = context;\r\n    resolverRef.current = resolver;\r\n    const reRender = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(() => !isUnMount.current && render({}), []);\r\n    const shouldRenderBaseOnError = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, error, shouldRender = false) => {\r\n        let shouldReRender = shouldRender ||\r\n            shouldRenderBasedOnError({\r\n                errors: errorsRef.current,\r\n                error,\r\n                name,\r\n                validFields: validFieldsRef.current,\r\n                fieldsWithValidation: fieldsWithValidationRef.current,\r\n            });\r\n        const previousError = get(errorsRef.current, name);\r\n        if (isEmptyObject(error)) {\r\n            if (fieldsWithValidationRef.current.has(name) || resolverRef.current) {\r\n                validFieldsRef.current.add(name);\r\n                shouldReRender = shouldReRender || previousError;\r\n            }\r\n            errorsRef.current = unset(errorsRef.current, name);\r\n        }\r\n        else {\r\n            validFieldsRef.current.delete(name);\r\n            shouldReRender =\r\n                shouldReRender ||\r\n                    !previousError ||\r\n                    !isSameError(previousError, error[name]);\r\n            set(errorsRef.current, name, error[name]);\r\n        }\r\n        if (shouldReRender && !isNullOrUndefined(shouldRender)) {\r\n            reRender();\r\n            return true;\r\n        }\r\n    }, []);\r\n    const setFieldValue = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(({ ref, options }, rawValue) => {\r\n        const value = isWeb && isHTMLElement(ref) && isNullOrUndefined(rawValue)\r\n            ? ''\r\n            : rawValue;\r\n        if (isRadioInput(ref) && options) {\r\n            options.forEach(({ ref: radioRef }) => (radioRef.checked = radioRef.value === value));\r\n        }\r\n        else if (isFileInput(ref) && !isString(value)) {\r\n            ref.files = value;\r\n        }\r\n        else if (isMultipleSelect(ref)) {\r\n            [...ref.options].forEach((selectRef) => (selectRef.selected = value.includes(selectRef.value)));\r\n        }\r\n        else if (isCheckBoxInput(ref) && options) {\r\n            options.length > 1\r\n                ? options.forEach(({ ref: checkboxRef }) => (checkboxRef.checked = String(value).includes(checkboxRef.value)))\r\n                : (options[0].ref.checked = !!value);\r\n        }\r\n        else {\r\n            ref.value = value;\r\n        }\r\n    }, []);\r\n    const setDirty = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name) => {\r\n        const { isDirty, dirtyFields } = readFormStateRef.current;\r\n        if (!fieldsRef.current[name] || (!isDirty && !dirtyFields)) {\r\n            return false;\r\n        }\r\n        const isFieldDirty = defaultValuesAtRenderRef.current[name] !==\r\n            getFieldValue(fieldsRef, name, unmountFieldsStateRef);\r\n        const isDirtyFieldExist = get(dirtyFieldsRef.current, name);\r\n        const isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n        const previousIsDirty = isDirtyRef.current;\r\n        if (isFieldDirty) {\r\n            set(dirtyFieldsRef.current, name, true);\r\n        }\r\n        else {\r\n            unset(dirtyFieldsRef.current, name);\r\n        }\r\n        isDirtyRef.current =\r\n            (isFieldArray &&\r\n                !deepEqual(get(getValues(), getFieldArrayParentName(name)), get(defaultValuesRef.current, getFieldArrayParentName(name)))) ||\r\n                !isEmptyObject(dirtyFieldsRef.current);\r\n        return ((isDirty && previousIsDirty !== isDirtyRef.current) ||\r\n            (dirtyFields && isDirtyFieldExist !== get(dirtyFieldsRef.current, name)));\r\n    }, []);\r\n    const executeValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (name, skipReRender) => {\r\n        if (fieldsRef.current[name]) {\r\n            const error = await validateField(fieldsRef, isValidateAllFieldCriteria, fieldsRef.current[name], unmountFieldsStateRef);\r\n            shouldRenderBaseOnError(name, error, skipReRender ? null : false);\r\n            return isEmptyObject(error);\r\n        }\r\n        return false;\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const executeSchemaOrResolverValidation = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (payload) => {\r\n        const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n        const previousFormIsValid = isValidRef.current;\r\n        isValidRef.current = isEmptyObject(errors);\r\n        if (isArray(payload)) {\r\n            const isInputsValid = payload\r\n                .map((name) => {\r\n                const error = get(errors, name);\r\n                if (error) {\r\n                    set(errorsRef.current, name, error);\r\n                }\r\n                else {\r\n                    unset(errorsRef.current, name);\r\n                }\r\n                return !error;\r\n            })\r\n                .every(Boolean);\r\n            reRender();\r\n            return isInputsValid;\r\n        }\r\n        else {\r\n            const error = get(errors, payload);\r\n            shouldRenderBaseOnError(payload, (error ? { [payload]: error } : {}), previousFormIsValid !== isValidRef.current);\r\n            return !error;\r\n        }\r\n    }, [shouldRenderBaseOnError, isValidateAllFieldCriteria]);\r\n    const trigger = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (name) => {\r\n        const fields = name || Object.keys(fieldsRef.current);\r\n        if (resolverRef.current) {\r\n            return executeSchemaOrResolverValidation(fields);\r\n        }\r\n        if (isArray(fields)) {\r\n            const result = await Promise.all(fields.map(async (data) => await executeValidation(data, true)));\r\n            reRender();\r\n            return result.every(Boolean);\r\n        }\r\n        return await executeValidation(fields);\r\n    }, [executeSchemaOrResolverValidation, executeValidation]);\r\n    const setInternalValues = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, value, { shouldDirty, shouldValidate }) => {\r\n        getPath(name, value).forEach((fieldName) => {\r\n            const data = {};\r\n            const field = fieldsRef.current[fieldName];\r\n            if (field) {\r\n                set(data, name, value);\r\n                setFieldValue(field, get(data, fieldName));\r\n                if (shouldDirty) {\r\n                    setDirty(fieldName);\r\n                }\r\n                if (shouldValidate) {\r\n                    trigger(fieldName);\r\n                }\r\n            }\r\n        });\r\n    }, [trigger, setFieldValue, setDirty]);\r\n    const setInternalValue = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((name, value, config) => {\r\n        if (fieldsRef.current[name]) {\r\n            setFieldValue(fieldsRef.current[name], value);\r\n            return config.shouldDirty && setDirty(name);\r\n        }\r\n        else if (!isPrimitive(value)) {\r\n            setInternalValues(name, value, config);\r\n        }\r\n        if (!shouldUnregister) {\r\n            unmountFieldsStateRef.current[name] = value;\r\n        }\r\n        return true;\r\n    }, [setDirty, setFieldValue, setInternalValues]);\r\n    const isFieldWatched = (name) => isWatchAllRef.current ||\r\n        watchFieldsRef.current.has(name) ||\r\n        watchFieldsRef.current.has((name.match(/\\w+/) || [])[0]);\r\n    const renderWatchedInputs = (name, found = true) => {\r\n        if (!isEmptyObject(watchFieldsHookRef.current)) {\r\n            for (const key in watchFieldsHookRef.current) {\r\n                if (name === '' ||\r\n                    watchFieldsHookRef.current[key].has(name) ||\r\n                    watchFieldsHookRef.current[key].has(getFieldArrayParentName(name)) ||\r\n                    !watchFieldsHookRef.current[key].size) {\r\n                    watchFieldsHookRenderRef.current[key]();\r\n                    found = false;\r\n                }\r\n            }\r\n        }\r\n        return found;\r\n    };\r\n    function setValue(name, value, config = {}) {\r\n        const shouldRender = setInternalValue(name, value, config) ||\r\n            isFieldWatched(name);\r\n        renderWatchedInputs(name);\r\n        if (shouldRender) {\r\n            reRender();\r\n        }\r\n        if (config.shouldValidate) {\r\n            trigger(name);\r\n        }\r\n    }\r\n    handleChangeRef.current = handleChangeRef.current\r\n        ? handleChangeRef.current\r\n        : async ({ type, target }) => {\r\n            const name = target.name;\r\n            const field = fieldsRef.current[name];\r\n            let error;\r\n            if (field) {\r\n                const isBlurEvent = type === EVENTS.BLUR;\r\n                const shouldSkipValidation = !isOnAll &&\r\n                    skipValidation(Object.assign({ isBlurEvent,\r\n                        isReValidateOnChange,\r\n                        isReValidateOnBlur, isSubmitted: isSubmittedRef.current }, modeRef.current));\r\n                let shouldRender = setDirty(name) || isFieldWatched(name);\r\n                if (isBlurEvent &&\r\n                    !get(touchedFieldsRef.current, name) &&\r\n                    readFormStateRef.current.touched) {\r\n                    set(touchedFieldsRef.current, name, true);\r\n                    shouldRender = true;\r\n                }\r\n                if (shouldSkipValidation) {\r\n                    renderWatchedInputs(name);\r\n                    return shouldRender && reRender();\r\n                }\r\n                if (resolverRef.current) {\r\n                    const { errors } = await resolverRef.current(getValues(), contextRef.current, isValidateAllFieldCriteria);\r\n                    const previousFormIsValid = isValidRef.current;\r\n                    isValidRef.current = isEmptyObject(errors);\r\n                    error = (get(errors, name)\r\n                        ? { [name]: get(errors, name) }\r\n                        : {});\r\n                    if (previousFormIsValid !== isValidRef.current) {\r\n                        shouldRender = true;\r\n                    }\r\n                }\r\n                else {\r\n                    error = await validateField(fieldsRef, isValidateAllFieldCriteria, field, unmountFieldsStateRef);\r\n                }\r\n                renderWatchedInputs(name);\r\n                if (!shouldRenderBaseOnError(name, error) && shouldRender) {\r\n                    reRender();\r\n                }\r\n            }\r\n        };\r\n    function getValues(payload) {\r\n        if (isString(payload)) {\r\n            return getFieldValue(fieldsRef, payload, unmountFieldsStateRef);\r\n        }\r\n        if (isArray(payload)) {\r\n            return payload.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: getFieldValue(fieldsRef, name, unmountFieldsStateRef) })), {});\r\n        }\r\n        return getFieldsValues(fieldsRef, unmountFieldsStateRef);\r\n    }\r\n    const validateResolver = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(async (values = {}) => {\r\n        const { errors } = await resolverRef.current(Object.assign(Object.assign(Object.assign({}, defaultValuesRef.current), getValues()), values), contextRef.current, isValidateAllFieldCriteria);\r\n        const previousFormIsValid = isValidRef.current;\r\n        isValidRef.current = isEmptyObject(errors);\r\n        if (previousFormIsValid !== isValidRef.current) {\r\n            reRender();\r\n        }\r\n    }, [isValidateAllFieldCriteria]);\r\n    const removeFieldEventListener = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((field, forceDelete) => findRemovedFieldAndRemoveListener(fieldsRef, handleChangeRef.current, field, unmountFieldsStateRef, shouldUnregister, forceDelete), [shouldUnregister]);\r\n    const removeFieldEventListenerAndRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((field, forceDelete) => {\r\n        if (field &&\r\n            (!isNameInFieldArray(fieldArrayNamesRef.current, field.ref.name) ||\r\n                forceDelete)) {\r\n            removeFieldEventListener(field, forceDelete);\r\n            if (shouldUnregister) {\r\n                [\r\n                    errorsRef,\r\n                    touchedFieldsRef,\r\n                    dirtyFieldsRef,\r\n                    defaultValuesAtRenderRef,\r\n                ].forEach((data) => unset(data.current, field.ref.name));\r\n                [fieldsWithValidationRef, validFieldsRef].forEach((data) => data.current.delete(field.ref.name));\r\n                if (readFormStateRef.current.isValid ||\r\n                    readFormStateRef.current.touched ||\r\n                    readFormStateRef.current.isDirty) {\r\n                    isDirtyRef.current = !isEmptyObject(dirtyFieldsRef.current);\r\n                    reRender();\r\n                    if (resolverRef.current) {\r\n                        validateResolver();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }, [validateResolver, removeFieldEventListener]);\r\n    function clearErrors(name) {\r\n        if (name) {\r\n            (isArray(name) ? name : [name]).forEach((inputName) => unset(errorsRef.current, inputName));\r\n        }\r\n        else {\r\n            errorsRef.current = {};\r\n        }\r\n        reRender();\r\n    }\r\n    function setError(name, error) {\r\n        isValidRef.current = false;\r\n        set(errorsRef.current, name, Object.assign(Object.assign({}, error), { ref: (fieldsRef.current[name] || {}).ref }));\r\n        reRender();\r\n    }\r\n    const watchInternal = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((fieldNames, defaultValue, watchId) => {\r\n        const watchFields = watchId\r\n            ? watchFieldsHookRef.current[watchId]\r\n            : watchFieldsRef.current;\r\n        const combinedDefaultValues = isUndefined(defaultValue)\r\n            ? defaultValuesRef.current\r\n            : defaultValue;\r\n        const fieldValues = getFieldsValues(fieldsRef, unmountFieldsStateRef, fieldNames);\r\n        if (isString(fieldNames)) {\r\n            return assignWatchFields(fieldValues, fieldNames, watchFields, isUndefined(defaultValue)\r\n                ? get(combinedDefaultValues, fieldNames)\r\n                : defaultValue, true);\r\n        }\r\n        if (isArray(fieldNames)) {\r\n            return fieldNames.reduce((previous, name) => (Object.assign(Object.assign({}, previous), { [name]: assignWatchFields(fieldValues, name, watchFields, combinedDefaultValues) })), {});\r\n        }\r\n        if (isUndefined(watchId)) {\r\n            isWatchAllRef.current = true;\r\n        }\r\n        return transformToNestObject((!isEmptyObject(fieldValues) && fieldValues) ||\r\n            combinedDefaultValues);\r\n    }, []);\r\n    function watch(fieldNames, defaultValue) {\r\n        return watchInternal(fieldNames, defaultValue);\r\n    }\r\n    function unregister(name) {\r\n        (isArray(name) ? name : [name]).forEach((fieldName) => removeFieldEventListenerAndRef(fieldsRef.current[fieldName], true));\r\n    }\r\n    function registerFieldRef(ref, validateOptions = {}) {\r\n        if (true) {\r\n            if (!ref.name) {\r\n                return console.warn('📋 Field is missing `name` attribute:', ref);\r\n            }\r\n            if (fieldArrayNamesRef.current.has(ref.name.split(/\\[\\d+\\]$/)[0]) &&\r\n                !RegExp(`^${ref.name.split(/\\[\\d+\\]$/)[0]}[\\\\d+]\\.\\\\w+`\r\n                    .replace(/\\[/g, '\\\\[')\r\n                    .replace(/\\]/g, '\\\\]')).test(ref.name)) {\r\n                return console.warn('📋 `name` prop should be in object shape: name=\"test[index].name\". https://react-hook-form.com/api#useFieldArray');\r\n            }\r\n        }\r\n        const { name, type, value } = ref;\r\n        const fieldRefAndValidationOptions = Object.assign({ ref }, validateOptions);\r\n        const fields = fieldsRef.current;\r\n        const isRadioOrCheckbox = isRadioOrCheckboxFunction(ref);\r\n        let field = fields[name];\r\n        let isEmptyDefaultValue = true;\r\n        let isFieldArray;\r\n        let defaultValue;\r\n        if (field &&\r\n            (isRadioOrCheckbox\r\n                ? isArray(field.options) &&\r\n                    unique(field.options).find((option) => {\r\n                        return value === option.ref.value && option.ref === ref;\r\n                    })\r\n                : ref === field.ref)) {\r\n            fields[name] = Object.assign(Object.assign({}, field), validateOptions);\r\n            return;\r\n        }\r\n        if (type) {\r\n            const mutationWatcher = onDomRemove(ref, () => removeFieldEventListenerAndRef(field));\r\n            field = isRadioOrCheckbox\r\n                ? Object.assign({ options: [\r\n                        ...unique((field && field.options) || []),\r\n                        {\r\n                            ref,\r\n                            mutationWatcher,\r\n                        },\r\n                    ], ref: { type, name } }, validateOptions) : Object.assign(Object.assign({}, fieldRefAndValidationOptions), { mutationWatcher });\r\n        }\r\n        else {\r\n            field = fieldRefAndValidationOptions;\r\n        }\r\n        fields[name] = field;\r\n        const isEmptyUnmountFields = isUndefined(get(unmountFieldsStateRef.current, name));\r\n        if (!isEmptyObject(defaultValuesRef.current) || !isEmptyUnmountFields) {\r\n            defaultValue = get(isEmptyUnmountFields\r\n                ? defaultValuesRef.current\r\n                : unmountFieldsStateRef.current, name);\r\n            isEmptyDefaultValue = isUndefined(defaultValue);\r\n            isFieldArray = isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n            if (!isEmptyDefaultValue && !isFieldArray) {\r\n                setFieldValue(field, defaultValue);\r\n            }\r\n        }\r\n        if (resolver && !isFieldArray && readFormStateRef.current.isValid) {\r\n            validateResolver();\r\n        }\r\n        else if (!isEmptyObject(validateOptions)) {\r\n            fieldsWithValidationRef.current.add(name);\r\n            if (!isOnSubmit && readFormStateRef.current.isValid) {\r\n                validateField(fieldsRef, isValidateAllFieldCriteria, field, unmountFieldsStateRef).then((error) => {\r\n                    const previousFormIsValid = isValidRef.current;\r\n                    isEmptyObject(error)\r\n                        ? validFieldsRef.current.add(name)\r\n                        : (isValidRef.current = false);\r\n                    if (previousFormIsValid !== isValidRef.current) {\r\n                        reRender();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        if (!defaultValuesAtRenderRef.current[name] &&\r\n            !(isFieldArray && isEmptyDefaultValue)) {\r\n            const fieldValue = getFieldValue(fieldsRef, name, unmountFieldsStateRef);\r\n            defaultValuesAtRenderRef.current[name] = isEmptyDefaultValue\r\n                ? isObject(fieldValue)\r\n                    ? Object.assign({}, fieldValue) : fieldValue\r\n                : defaultValue;\r\n        }\r\n        if (type) {\r\n            attachEventListeners(isRadioOrCheckbox && field.options\r\n                ? field.options[field.options.length - 1]\r\n                : field, isRadioOrCheckbox || isSelectInput(ref), handleChangeRef.current);\r\n        }\r\n    }\r\n    function register(refOrValidationOptions, rules) {\r\n        if (!isWindowUndefined) {\r\n            if (isString(refOrValidationOptions)) {\r\n                registerFieldRef({ name: refOrValidationOptions }, rules);\r\n            }\r\n            else if (isObject(refOrValidationOptions) &&\r\n                'name' in refOrValidationOptions) {\r\n                registerFieldRef(refOrValidationOptions, rules);\r\n            }\r\n            else {\r\n                return (ref) => ref && registerFieldRef(ref, refOrValidationOptions);\r\n            }\r\n        }\r\n    }\r\n    const handleSubmit = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])((callback) => async (e) => {\r\n        if (e && e.preventDefault) {\r\n            e.preventDefault();\r\n            e.persist();\r\n        }\r\n        let fieldErrors = {};\r\n        let fieldValues = getFieldsValues(fieldsRef, unmountFieldsStateRef);\r\n        if (readFormStateRef.current.isSubmitting) {\r\n            isSubmittingRef.current = true;\r\n            reRender();\r\n        }\r\n        try {\r\n            if (resolverRef.current) {\r\n                const { errors, values } = await resolverRef.current(fieldValues, contextRef.current, isValidateAllFieldCriteria);\r\n                errorsRef.current = errors;\r\n                fieldErrors = errors;\r\n                fieldValues = values;\r\n            }\r\n            else {\r\n                for (const field of Object.values(fieldsRef.current)) {\r\n                    if (field) {\r\n                        const { ref: { name }, } = field;\r\n                        const fieldError = await validateField(fieldsRef, isValidateAllFieldCriteria, field, unmountFieldsStateRef);\r\n                        if (fieldError[name]) {\r\n                            set(fieldErrors, name, fieldError[name]);\r\n                            validFieldsRef.current.delete(name);\r\n                        }\r\n                        else if (fieldsWithValidationRef.current.has(name)) {\r\n                            unset(errorsRef.current, name);\r\n                            validFieldsRef.current.add(name);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (isEmptyObject(fieldErrors) &&\r\n                Object.keys(errorsRef.current).every((name) => Object.keys(fieldsRef.current).includes(name))) {\r\n                errorsRef.current = {};\r\n                reRender();\r\n                await callback(fieldValues, e);\r\n            }\r\n            else {\r\n                errorsRef.current = Object.assign(Object.assign({}, errorsRef.current), fieldErrors);\r\n                if (shouldFocusError) {\r\n                    focusOnErrorField(fieldsRef.current, fieldErrors);\r\n                }\r\n            }\r\n        }\r\n        finally {\r\n            isSubmittedRef.current = true;\r\n            isSubmittingRef.current = false;\r\n            submitCountRef.current = submitCountRef.current + 1;\r\n            reRender();\r\n        }\r\n    }, [shouldFocusError, isValidateAllFieldCriteria]);\r\n    const resetRefs = ({ errors, isDirty, isSubmitted, touched, isValid, submitCount, dirtyFields, }) => {\r\n        if (!errors) {\r\n            errorsRef.current = {};\r\n        }\r\n        if (!touched) {\r\n            touchedFieldsRef.current = {};\r\n        }\r\n        if (!isValid) {\r\n            validFieldsRef.current = new Set();\r\n            fieldsWithValidationRef.current = new Set();\r\n            isValidRef.current = true;\r\n        }\r\n        if (!isDirty) {\r\n            isDirtyRef.current = false;\r\n        }\r\n        if (!dirtyFields) {\r\n            dirtyFieldsRef.current = {};\r\n        }\r\n        if (!isSubmitted) {\r\n            isSubmittedRef.current = false;\r\n        }\r\n        if (!submitCount) {\r\n            submitCountRef.current = 0;\r\n        }\r\n        defaultValuesAtRenderRef.current = {};\r\n        fieldArrayDefaultValues.current = {};\r\n        watchFieldsRef.current = new Set();\r\n        isWatchAllRef.current = false;\r\n    };\r\n    const reset = (values, omitResetState = {}) => {\r\n        if (isWeb) {\r\n            for (const field of Object.values(fieldsRef.current)) {\r\n                if (field) {\r\n                    const { ref, options } = field;\r\n                    const inputRef = isRadioOrCheckboxFunction(ref) && isArray(options)\r\n                        ? options[0].ref\r\n                        : ref;\r\n                    if (isHTMLElement(inputRef)) {\r\n                        try {\r\n                            inputRef.closest('form').reset();\r\n                            break;\r\n                        }\r\n                        catch (_a) { }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        fieldsRef.current = {};\r\n        defaultValuesRef.current = values || Object.assign({}, defaultValuesRef.current);\r\n        if (values) {\r\n            renderWatchedInputs('');\r\n        }\r\n        unmountFieldsStateRef.current = shouldUnregister ? {} : values || {};\r\n        Object.values(resetFieldArrayFunctionRef.current).forEach((resetFieldArray) => isFunction(resetFieldArray) && resetFieldArray());\r\n        resetRefs(omitResetState);\r\n        reRender();\r\n    };\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        isUnMount.current = false;\r\n        return () => {\r\n            isUnMount.current = true;\r\n            fieldsRef.current &&\r\n                \"development\" === 'production' &&\r\n                Object.values(fieldsRef.current).forEach((field) => removeFieldEventListenerAndRef(field, true));\r\n        };\r\n    }, [removeFieldEventListenerAndRef]);\r\n    if (!resolver) {\r\n        isValidRef.current =\r\n            validFieldsRef.current.size >= fieldsWithValidationRef.current.size &&\r\n                isEmptyObject(errorsRef.current);\r\n    }\r\n    const formState = {\r\n        dirtyFields: dirtyFieldsRef.current,\r\n        isSubmitted: isSubmittedRef.current,\r\n        submitCount: submitCountRef.current,\r\n        touched: touchedFieldsRef.current,\r\n        isDirty: isDirtyRef.current,\r\n        isSubmitting: isSubmittingRef.current,\r\n        isValid: isOnSubmit\r\n            ? isSubmittedRef.current && isEmptyObject(errorsRef.current)\r\n            : isValidRef.current,\r\n    };\r\n    const commonProps = {\r\n        trigger,\r\n        setValue: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(setValue, [\r\n            reRender,\r\n            setInternalValue,\r\n            trigger,\r\n        ]),\r\n        getValues: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(getValues, []),\r\n        register: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(register, [defaultValuesRef.current]),\r\n        unregister: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(unregister, []),\r\n        formState: isProxyEnabled\r\n            ? new Proxy(formState, {\r\n                get: (obj, prop) => {\r\n                    if ( true &&\r\n                        prop === 'isValid' &&\r\n                        isOnSubmit) {\r\n                        console.warn('📋 `formState.isValid` is applicable with `onChange` or `onBlur` mode. https://react-hook-form.com/api#formState');\r\n                    }\r\n                    if (prop in obj) {\r\n                        readFormStateRef.current[prop] = true;\r\n                        return obj[prop];\r\n                    }\r\n                    return undefined;\r\n                },\r\n            })\r\n            : formState,\r\n    };\r\n    const control = Object.assign(Object.assign({ removeFieldEventListener,\r\n        renderWatchedInputs,\r\n        watchInternal,\r\n        reRender, mode: modeRef.current, reValidateMode: {\r\n            isReValidateOnBlur,\r\n            isReValidateOnChange,\r\n        }, errorsRef,\r\n        touchedFieldsRef,\r\n        fieldsRef,\r\n        isWatchAllRef,\r\n        watchFieldsRef,\r\n        resetFieldArrayFunctionRef,\r\n        watchFieldsHookRef,\r\n        watchFieldsHookRenderRef,\r\n        fieldArrayDefaultValues,\r\n        validFieldsRef,\r\n        dirtyFieldsRef,\r\n        fieldsWithValidationRef,\r\n        fieldArrayNamesRef,\r\n        isDirtyRef,\r\n        isSubmittedRef,\r\n        readFormStateRef,\r\n        defaultValuesRef,\r\n        unmountFieldsStateRef }, (resolver ? { validateSchemaIsValid: validateResolver } : {})), commonProps);\r\n    return Object.assign({ watch,\r\n        control,\r\n        handleSubmit, reset: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(reset, []), clearErrors: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(clearErrors, []), setError: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(setError, []), errors: errorsRef.current }, commonProps);\r\n}\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\n\nconst FormContext = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createContext\"])(null);\r\nFormContext.displayName = 'RHFContext';\r\nconst useFormContext = () => Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useContext\"])(FormContext);\r\nconst FormProvider = (_a) => {\r\n    var { children } = _a, props = __rest(_a, [\"children\"]);\r\n    return (Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(FormContext.Provider, { value: Object.assign({}, props) }, children));\r\n};\n\nvar generateId = () => {\r\n    const d = typeof performance === UNDEFINED ? Date.now() : performance.now() * 1000;\r\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\r\n        const r = (Math.random() * 16 + d) % 16 | 0;\r\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\r\n    });\r\n};\n\nconst removeAt = (data, index) => [\r\n    ...data.slice(0, index),\r\n    ...data.slice(index + 1),\r\n];\r\nfunction removeAtIndexes(data, index) {\r\n    let k = -1;\r\n    while (++k < data.length) {\r\n        if (index.indexOf(k) >= 0) {\r\n            delete data[k];\r\n        }\r\n    }\r\n    return unique(data);\r\n}\r\nvar removeArrayAt = (data, index) => isUndefined(index)\r\n    ? []\r\n    : isArray(index)\r\n        ? removeAtIndexes(data, index)\r\n        : removeAt(data, index);\n\nvar moveArrayAt = (data, from, to) => {\r\n    if (isArray(data)) {\r\n        if (isUndefined(data[to])) {\r\n            data[to] = undefined;\r\n        }\r\n        data.splice(to, 0, data.splice(from, 1)[0]);\r\n        return data;\r\n    }\r\n    return [];\r\n};\n\nvar swapArrayAt = (data, indexA, indexB) => {\r\n    const temp = [data[indexB], data[indexA]];\r\n    data[indexA] = temp[0];\r\n    data[indexB] = temp[1];\r\n};\n\nfunction prepend(data, value) {\r\n    return [...(isArray(value) ? value : [value || undefined]), ...data];\r\n}\n\nfunction insert(data, index, value) {\r\n    return [\r\n        ...data.slice(0, index),\r\n        ...(isArray(value) ? value : [value || undefined]),\r\n        ...data.slice(index),\r\n    ];\r\n}\n\nvar fillEmptyArray = (value) => isArray(value) ? Array(value.length).fill(undefined) : undefined;\n\nfunction mapValueToBoolean(value) {\r\n    if (isObject(value)) {\r\n        const object = {};\r\n        for (const key in value) {\r\n            object[key] = true;\r\n        }\r\n        return [object];\r\n    }\r\n    return [true];\r\n}\r\nconst filterBooleanArray = (value) => isArray(value)\r\n    ? value.map(mapValueToBoolean).flat()\r\n    : mapValueToBoolean(value);\n\nconst appendId = (value, keyName) => (Object.assign({ [keyName]: generateId() }, (isObject(value) ? value : { value })));\r\nconst mapIds = (data, keyName) => (isArray(data) ? data : []).map((value) => appendId(value, keyName));\r\nconst useFieldArray = ({ control, name, keyName = 'id', }) => {\r\n    const methods = useFormContext();\r\n    if (true) {\r\n        if (!control && !methods) {\r\n            throw new Error('📋 useFieldArray is missing `control` prop.');\r\n        }\r\n        if (!name) {\r\n            console.warn('📋 useFieldArray is missing `name` attribute.');\r\n        }\r\n    }\r\n    const focusIndexRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(-1);\r\n    const { isWatchAllRef, resetFieldArrayFunctionRef, fieldArrayNamesRef, reRender, fieldsRef, defaultValuesRef, removeFieldEventListener, errorsRef, dirtyFieldsRef, isDirtyRef, touchedFieldsRef, readFormStateRef, watchFieldsRef, validFieldsRef, fieldsWithValidationRef, fieldArrayDefaultValues, validateSchemaIsValid, renderWatchedInputs, getValues, } = control || methods.control;\r\n    let shouldRender;\r\n    const getDefaultValues = () => [\r\n        ...(get(fieldArrayDefaultValues.current, name) ||\r\n            get(defaultValuesRef.current, name) ||\r\n            []),\r\n    ];\r\n    const memoizedDefaultValues = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(getDefaultValues());\r\n    const [fields, setField] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(mapIds(memoizedDefaultValues.current, keyName));\r\n    const allFields = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(fields);\r\n    const rootParentName = getFieldArrayParentName(name);\r\n    const getCurrentFieldsValues = () => get(getValues() || {}, name, allFields.current).map((item, index) => (Object.assign(Object.assign({}, allFields.current[index]), item)));\r\n    allFields.current = fields;\r\n    fieldArrayNamesRef.current.add(name);\r\n    if (!get(fieldArrayDefaultValues.current, name) && rootParentName) {\r\n        set(fieldArrayDefaultValues.current, rootParentName, get(defaultValuesRef.current, rootParentName));\r\n    }\r\n    const appendValueWithKey = (values) => values.map((value) => appendId(value, keyName));\r\n    const setFieldAndValidState = (fieldsValues) => {\r\n        setField(fieldsValues);\r\n        if (readFormStateRef.current.isValid && validateSchemaIsValid) {\r\n            validateSchemaIsValid({\r\n                [name]: fieldsValues,\r\n            });\r\n        }\r\n    };\r\n    const shouldRenderFieldArray = (shouldRender) => {\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.isValid) {\r\n            shouldRender = true;\r\n        }\r\n        renderWatchedInputs(name);\r\n        shouldRender && !isWatchAllRef.current && reRender();\r\n    };\r\n    const resetFields = (flagOrFields) => {\r\n        if (readFormStateRef.current.isDirty ||\r\n            readFormStateRef.current.dirtyFields) {\r\n            isDirtyRef.current =\r\n                isUndefined(flagOrFields) ||\r\n                    !deepEqual(flagOrFields.map((_a = {}) => {\r\n                        var _b = keyName, omitted = _a[_b], rest = __rest(_a, [typeof _b === \"symbol\" ? _b : _b + \"\"]);\r\n                        return rest;\r\n                    }), get(defaultValuesRef.current, name, []));\r\n        }\r\n        for (const key in fieldsRef.current) {\r\n            if (isMatchFieldArrayName(key, name) && fieldsRef.current[key]) {\r\n                removeFieldEventListener(fieldsRef.current[key], true);\r\n            }\r\n        }\r\n    };\r\n    const append = (value, shouldFocus = true) => {\r\n        shouldRender = false;\r\n        setFieldAndValidState([\r\n            ...allFields.current,\r\n            ...(isArray(value)\r\n                ? appendValueWithKey(value)\r\n                : [appendId(value, keyName)]),\r\n        ]);\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(dirtyFieldsRef.current, name, [\r\n                ...(get(dirtyFieldsRef.current, name) ||\r\n                    fillEmptyArray(fields.slice(0, 1))),\r\n                ...filterBooleanArray(value),\r\n            ]);\r\n            isDirtyRef.current = true;\r\n            shouldRender = true;\r\n        }\r\n        focusIndexRef.current = shouldFocus ? allFields.current.length : -1;\r\n        shouldRenderFieldArray(shouldRender);\r\n    };\r\n    const prepend$1 = (value, shouldFocus = true) => {\r\n        const emptyArray = fillEmptyArray(value);\r\n        shouldRender = false;\r\n        setFieldAndValidState(prepend(getCurrentFieldsValues(), isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        resetFields();\r\n        if (isArray(get(errorsRef.current, name))) {\r\n            set(errorsRef.current, name, prepend(get(errorsRef.current, name), emptyArray));\r\n        }\r\n        if (readFormStateRef.current.touched &&\r\n            get(touchedFieldsRef.current, name)) {\r\n            set(touchedFieldsRef.current, name, prepend(get(touchedFieldsRef.current, name), emptyArray));\r\n            shouldRender = true;\r\n        }\r\n        if (readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) {\r\n            set(dirtyFieldsRef.current, name, prepend(get(dirtyFieldsRef.current, name) || [], filterBooleanArray(value)));\r\n            shouldRender = true;\r\n        }\r\n        shouldRenderFieldArray(shouldRender);\r\n        focusIndexRef.current = shouldFocus ? 0 : -1;\r\n    };\r\n    const remove = (index) => {\r\n        shouldRender = false;\r\n        const fieldValues = getCurrentFieldsValues();\r\n        setFieldAndValidState(removeArrayAt(fieldValues, index));\r\n        resetFields(removeArrayAt(fieldValues, index));\r\n        if (isArray(get(errorsRef.current, name))) {\r\n            set(errorsRef.current, name, removeArrayAt(get(errorsRef.current, name), index));\r\n            if (!unique(get(errorsRef.current, name, [])).length) {\r\n                unset(errorsRef.current, name);\r\n            }\r\n        }\r\n        if (readFormStateRef.current.touched &&\r\n            get(touchedFieldsRef.current, name)) {\r\n            set(touchedFieldsRef.current, name, removeArrayAt(get(touchedFieldsRef.current, name), index));\r\n            shouldRender = true;\r\n        }\r\n        if ((readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) &&\r\n            get(dirtyFieldsRef.current, name)) {\r\n            set(dirtyFieldsRef.current, name, removeArrayAt(get(dirtyFieldsRef.current, name), index));\r\n            if (!unique(get(dirtyFieldsRef.current, name, [])).length) {\r\n                unset(dirtyFieldsRef.current, name);\r\n            }\r\n            shouldRender = true;\r\n        }\r\n        if (readFormStateRef.current.isValid && !validateSchemaIsValid) {\r\n            let fieldIndex = -1;\r\n            let isFound = false;\r\n            const isIndexUndefined = isUndefined(index);\r\n            while (fieldIndex++ < fields.length) {\r\n                const isLast = fieldIndex === fields.length - 1;\r\n                const isCurrentIndex = (isArray(index) ? index : [index]).indexOf(fieldIndex) >= 0;\r\n                if (isCurrentIndex || isIndexUndefined) {\r\n                    isFound = true;\r\n                }\r\n                if (!isFound) {\r\n                    continue;\r\n                }\r\n                for (const key in fields[fieldIndex]) {\r\n                    const currentFieldName = `${name}[${fieldIndex}].${key}`;\r\n                    if (isCurrentIndex || isLast || isIndexUndefined) {\r\n                        validFieldsRef.current.delete(currentFieldName);\r\n                        fieldsWithValidationRef.current.delete(currentFieldName);\r\n                    }\r\n                    else {\r\n                        const previousFieldName = `${name}[${fieldIndex - 1}].${key}`;\r\n                        if (validFieldsRef.current.has(currentFieldName)) {\r\n                            validFieldsRef.current.add(previousFieldName);\r\n                        }\r\n                        if (fieldsWithValidationRef.current.has(currentFieldName)) {\r\n                            fieldsWithValidationRef.current.add(previousFieldName);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        shouldRenderFieldArray(shouldRender);\r\n    };\r\n    const insert$1 = (index, value, shouldFocus = true) => {\r\n        shouldRender = false;\r\n        const emptyArray = fillEmptyArray(value);\r\n        const fieldValues = getCurrentFieldsValues();\r\n        setFieldAndValidState(insert(fieldValues, index, isArray(value) ? appendValueWithKey(value) : [appendId(value, keyName)]));\r\n        resetFields(insert(fieldValues, index));\r\n        if (isArray(get(errorsRef.current, name))) {\r\n            set(errorsRef.current, name, insert(get(errorsRef.current, name), index, emptyArray));\r\n        }\r\n        if (readFormStateRef.current.touched &&\r\n            get(touchedFieldsRef.current, name)) {\r\n            set(touchedFieldsRef.current, name, insert(get(touchedFieldsRef.current, name), index, emptyArray));\r\n            shouldRender = true;\r\n        }\r\n        if ((readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) &&\r\n            get(dirtyFieldsRef.current, name)) {\r\n            set(dirtyFieldsRef.current, name, insert(get(dirtyFieldsRef.current, name), index, filterBooleanArray(value)));\r\n            shouldRender = true;\r\n        }\r\n        shouldRenderFieldArray(shouldRender);\r\n        focusIndexRef.current = shouldFocus ? index : -1;\r\n    };\r\n    const swap = (indexA, indexB) => {\r\n        shouldRender = false;\r\n        const fieldValues = getCurrentFieldsValues();\r\n        swapArrayAt(fieldValues, indexA, indexB);\r\n        resetFields(fieldValues);\r\n        setFieldAndValidState([...fieldValues]);\r\n        if (isArray(get(errorsRef.current, name))) {\r\n            swapArrayAt(get(errorsRef.current, name), indexA, indexB);\r\n        }\r\n        if (readFormStateRef.current.touched &&\r\n            get(touchedFieldsRef.current, name)) {\r\n            swapArrayAt(get(touchedFieldsRef.current, name), indexA, indexB);\r\n            shouldRender = true;\r\n        }\r\n        if ((readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) &&\r\n            get(dirtyFieldsRef.current, name)) {\r\n            swapArrayAt(get(dirtyFieldsRef.current, name), indexA, indexB);\r\n            shouldRender = true;\r\n        }\r\n        shouldRenderFieldArray(shouldRender);\r\n    };\r\n    const move = (from, to) => {\r\n        shouldRender = false;\r\n        const fieldValues = getCurrentFieldsValues();\r\n        moveArrayAt(fieldValues, from, to);\r\n        resetFields(fieldValues);\r\n        setFieldAndValidState([...fieldValues]);\r\n        if (isArray(get(errorsRef.current, name))) {\r\n            moveArrayAt(get(errorsRef.current, name), from, to);\r\n        }\r\n        if (readFormStateRef.current.touched &&\r\n            get(touchedFieldsRef.current, name)) {\r\n            moveArrayAt(get(touchedFieldsRef.current, name), from, to);\r\n            shouldRender = true;\r\n        }\r\n        if ((readFormStateRef.current.dirtyFields ||\r\n            readFormStateRef.current.isDirty) &&\r\n            get(dirtyFieldsRef.current, name)) {\r\n            moveArrayAt(get(dirtyFieldsRef.current, name), from, to);\r\n            shouldRender = true;\r\n        }\r\n        shouldRenderFieldArray(shouldRender);\r\n    };\r\n    const reset = () => {\r\n        resetFields();\r\n        memoizedDefaultValues.current = getDefaultValues();\r\n        setField(mapIds(memoizedDefaultValues.current, keyName));\r\n    };\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        const defaultValues = get(fieldArrayDefaultValues.current, name);\r\n        if (defaultValues && fields.length < defaultValues.length) {\r\n            defaultValues.pop();\r\n            set(fieldArrayDefaultValues.current, name, defaultValues);\r\n        }\r\n        if (isWatchAllRef.current) {\r\n            reRender();\r\n        }\r\n        else if (watchFieldsRef) {\r\n            let shouldRenderUseWatch = true;\r\n            for (const watchField of watchFieldsRef.current) {\r\n                if (watchField.startsWith(name)) {\r\n                    reRender();\r\n                    shouldRenderUseWatch = false;\r\n                    break;\r\n                }\r\n            }\r\n            shouldRenderUseWatch && renderWatchedInputs(name);\r\n        }\r\n        if (focusIndexRef.current > -1) {\r\n            for (const key in fieldsRef.current) {\r\n                const field = fieldsRef.current[key];\r\n                if (key.startsWith(`${name}[${focusIndexRef.current}]`) &&\r\n                    field.ref.focus) {\r\n                    field.ref.focus();\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        focusIndexRef.current = -1;\r\n    }, [\r\n        fields,\r\n        name,\r\n        fieldArrayDefaultValues,\r\n        reRender,\r\n        fieldsRef,\r\n        watchFieldsRef,\r\n        isWatchAllRef,\r\n    ]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        const resetFunctions = resetFieldArrayFunctionRef.current;\r\n        resetFunctions[name] = reset;\r\n        return () => {\r\n            resetFields();\r\n            delete resetFunctions[name];\r\n            fieldArrayNamesRef.current.delete(name);\r\n        };\r\n        // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    }, []);\r\n    return {\r\n        swap: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(swap, [name]),\r\n        move: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(move, [name]),\r\n        prepend: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(prepend$1, [name]),\r\n        append: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(append, [name]),\r\n        remove: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(remove, [fields, name]),\r\n        insert: Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(insert$1, [name]),\r\n        fields,\r\n    };\r\n};\n\nfunction useWatch({ control, name, defaultValue, }) {\r\n    const methods = useFormContext();\r\n    if (true) {\r\n        if (!control && !methods) {\r\n            throw new Error('📋 useWatch is missing `control` prop.');\r\n        }\r\n        if (name === '') {\r\n            console.warn('📋 useWatch is missing `name` attribute.');\r\n        }\r\n    }\r\n    const { watchFieldsHookRef, watchFieldsHookRenderRef, watchInternal, defaultValuesRef, } = control || methods.control;\r\n    const [value, setValue] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(isUndefined(defaultValue)\r\n        ? isString(name)\r\n            ? get(defaultValuesRef.current, name)\r\n            : isArray(name)\r\n                ? name.reduce((previous, inputName) => (Object.assign(Object.assign({}, previous), { [inputName]: get(defaultValuesRef.current, inputName) })), {})\r\n                : defaultValuesRef.current\r\n        : defaultValue);\r\n    const idRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])();\r\n    const defaultValueRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(defaultValue);\r\n    const updateWatchValue = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(() => setValue(watchInternal(name, defaultValueRef.current, idRef.current)), [setValue, watchInternal, defaultValueRef, name, idRef]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        const id = (idRef.current = generateId());\r\n        const watchFieldsHookRender = watchFieldsHookRenderRef.current;\r\n        const watchFieldsHook = watchFieldsHookRef.current;\r\n        watchFieldsHook[id] = new Set();\r\n        watchFieldsHookRender[id] = updateWatchValue;\r\n        watchInternal(name, defaultValueRef.current, id);\r\n        return () => {\r\n            delete watchFieldsHook[id];\r\n            delete watchFieldsHookRender[id];\r\n        };\r\n    }, [\r\n        name,\r\n        updateWatchValue,\r\n        watchFieldsHookRenderRef,\r\n        watchFieldsHookRef,\r\n        watchInternal,\r\n        defaultValueRef,\r\n    ]);\r\n    return (isUndefined(value) ? defaultValue : value);\r\n}\n\nvar getInputValue = (event) => isPrimitive(event) ||\r\n    !isObject(event.target) ||\r\n    (isObject(event.target) && !event.type)\r\n    ? event\r\n    : isUndefined(event.target.value)\r\n        ? event.target.checked\r\n        : event.target.value;\n\nconst Controller = (_a) => {\r\n    var { name, rules, as, render, defaultValue, control, onFocus } = _a, rest = __rest(_a, [\"name\", \"rules\", \"as\", \"render\", \"defaultValue\", \"control\", \"onFocus\"]);\r\n    const methods = useFormContext();\r\n    if ( true && !control && !methods) {\r\n        throw new Error('📋 Controller is missing `control` prop.');\r\n    }\r\n    const { defaultValuesRef, setValue, register, unregister, trigger, mode, reValidateMode: { isReValidateOnBlur, isReValidateOnChange }, isSubmittedRef, touchedFieldsRef, readFormStateRef, reRender, fieldsRef, fieldArrayNamesRef, unmountFieldsStateRef, } = control || methods.control;\r\n    const isNotFieldArray = !isNameInFieldArray(fieldArrayNamesRef.current, name);\r\n    const getInitialValue = () => !isUndefined(get(unmountFieldsStateRef.current, name)) && isNotFieldArray\r\n        ? unmountFieldsStateRef.current[name]\r\n        : isUndefined(defaultValue)\r\n            ? get(defaultValuesRef.current, name)\r\n            : defaultValue;\r\n    const [value, setInputStateValue] = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useState\"])(getInitialValue());\r\n    const valueRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(value);\r\n    const onFocusRef = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useRef\"])(onFocus);\r\n    const isSubmitted = isSubmittedRef.current;\r\n    if (true) {\r\n        if (isUndefined(value)) {\r\n            console.warn('📋 Controller `defaultValue` or useForm `defaultValues` is missing.');\r\n        }\r\n        if (as && render) {\r\n            console.warn('📋 Should use either `as` or `render` prop.');\r\n        }\r\n        if (!isNotFieldArray && isUndefined(defaultValue)) {\r\n            console.warn('📋 Controller is missing `defaultValue` prop when using `useFieldArray`.');\r\n        }\r\n    }\r\n    const shouldValidate = (isBlurEvent) => !skipValidation(Object.assign({ isBlurEvent,\r\n        isReValidateOnBlur,\r\n        isReValidateOnChange,\r\n        isSubmitted }, mode));\r\n    const commonTask = ([event]) => {\r\n        const data = getInputValue(event);\r\n        setInputStateValue(data);\r\n        valueRef.current = data;\r\n        return data;\r\n    };\r\n    const registerField = Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useCallback\"])(() => {\r\n        if ( true && !name) {\r\n            return console.warn('📋 Field is missing `name` prop.');\r\n        }\r\n        if (fieldsRef.current[name]) {\r\n            fieldsRef.current[name] = Object.assign({ ref: fieldsRef.current[name].ref }, rules);\r\n        }\r\n        else {\r\n            register(Object.defineProperty({ name, focus: onFocusRef.current }, VALUE, {\r\n                set(data) {\r\n                    setInputStateValue(data);\r\n                    valueRef.current = data;\r\n                },\r\n                get() {\r\n                    return valueRef.current;\r\n                },\r\n            }), rules);\r\n            if (isNotFieldArray && !get(defaultValuesRef.current, name)) {\r\n                setInputStateValue(getInitialValue());\r\n            }\r\n        }\r\n    }, [fieldsRef, rules, name, onFocusRef, register]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => () => {\r\n        !isNameInFieldArray(fieldArrayNamesRef.current, name) && unregister(name);\r\n    }, [unregister, name, fieldArrayNamesRef]);\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        registerField();\r\n    }, [registerField]);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(() => {\r\n        if (!fieldsRef.current[name]) {\r\n            registerField();\r\n            if (isNotFieldArray) {\r\n                setInputStateValue(getInitialValue());\r\n            }\r\n        }\r\n    });\r\n    const onBlur = () => {\r\n        if (readFormStateRef.current.touched &&\r\n            !get(touchedFieldsRef.current, name)) {\r\n            set(touchedFieldsRef.current, name, true);\r\n            reRender();\r\n        }\r\n        if (shouldValidate(true)) {\r\n            trigger(name);\r\n        }\r\n    };\r\n    const onChange = (...event) => setValue(name, commonTask(event), {\r\n        shouldValidate: shouldValidate(),\r\n        shouldDirty: true,\r\n    });\r\n    const props = Object.assign(Object.assign({}, rest), { onChange,\r\n        onBlur,\r\n        name,\r\n        value });\r\n    return as\r\n        ? Object(react__WEBPACK_IMPORTED_MODULE_0__[\"isValidElement\"])(as)\r\n            ? Object(react__WEBPACK_IMPORTED_MODULE_0__[\"cloneElement\"])(as, props)\r\n            : Object(react__WEBPACK_IMPORTED_MODULE_0__[\"createElement\"])(as, props)\r\n        : render\r\n            ? render({\r\n                onChange,\r\n                onBlur,\r\n                value,\r\n            })\r\n            : null;\r\n};\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QtaG9vay1mb3JtL2Rpc3QvaW5kZXguZXNtLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWhvb2stZm9ybS9kaXN0L2luZGV4LmVzbS5qcz8zNGEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzVmFsaWRFbGVtZW50LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCBjcmVhdGVFbGVtZW50LCBjbG9uZUVsZW1lbnQgfSBmcm9tICdyZWFjdCc7XG5cbnZhciBpc0hUTUxFbGVtZW50ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuXG5jb25zdCBFVkVOVFMgPSB7XHJcbiAgICBCTFVSOiAnYmx1cicsXHJcbiAgICBDSEFOR0U6ICdjaGFuZ2UnLFxyXG4gICAgSU5QVVQ6ICdpbnB1dCcsXHJcbn07XHJcbmNvbnN0IFZBTElEQVRJT05fTU9ERSA9IHtcclxuICAgIG9uQmx1cjogJ29uQmx1cicsXHJcbiAgICBvbkNoYW5nZTogJ29uQ2hhbmdlJyxcclxuICAgIG9uU3VibWl0OiAnb25TdWJtaXQnLFxyXG4gICAgYWxsOiAnYWxsJyxcclxufTtcclxuY29uc3QgVkFMVUUgPSAndmFsdWUnO1xyXG5jb25zdCBTRUxFQ1QgPSAnc2VsZWN0JztcclxuY29uc3QgVU5ERUZJTkVEID0gJ3VuZGVmaW5lZCc7XHJcbmNvbnN0IElOUFVUX1ZBTElEQVRJT05fUlVMRVMgPSB7XHJcbiAgICBtYXg6ICdtYXgnLFxyXG4gICAgbWluOiAnbWluJyxcclxuICAgIG1heExlbmd0aDogJ21heExlbmd0aCcsXHJcbiAgICBtaW5MZW5ndGg6ICdtaW5MZW5ndGgnLFxyXG4gICAgcGF0dGVybjogJ3BhdHRlcm4nLFxyXG4gICAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXHJcbiAgICB2YWxpZGF0ZTogJ3ZhbGlkYXRlJyxcclxufTtcblxuZnVuY3Rpb24gYXR0YWNoRXZlbnRMaXN0ZW5lcnMoeyByZWYgfSwgc2hvdWxkQXR0YWNoQ2hhbmdlRXZlbnQsIGhhbmRsZUNoYW5nZSkge1xyXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQocmVmKSAmJiBoYW5kbGVDaGFuZ2UpIHtcclxuICAgICAgICByZWYuYWRkRXZlbnRMaXN0ZW5lcihzaG91bGRBdHRhY2hDaGFuZ2VFdmVudCA/IEVWRU5UUy5DSEFOR0UgOiBFVkVOVFMuSU5QVVQsIGhhbmRsZUNoYW5nZSk7XHJcbiAgICAgICAgcmVmLmFkZEV2ZW50TGlzdGVuZXIoRVZFTlRTLkJMVVIsIGhhbmRsZUNoYW5nZSk7XHJcbiAgICB9XHJcbn1cblxudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gKHZhbHVlKSA9PiB2YWx1ZSA9PSBudWxsO1xuXG52YXIgaXNBcnJheSA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG5cbmNvbnN0IGlzT2JqZWN0VHlwZSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JztcclxudmFyIGlzT2JqZWN0ID0gKHZhbHVlKSA9PiAhaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpICYmICFpc0FycmF5KHZhbHVlKSAmJiBpc09iamVjdFR5cGUodmFsdWUpO1xuXG52YXIgaXNLZXkgPSAodmFsdWUpID0+ICFpc0FycmF5KHZhbHVlKSAmJlxyXG4gICAgKC9eXFx3KiQvLnRlc3QodmFsdWUpIHx8XHJcbiAgICAgICAgIS9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8udGVzdCh2YWx1ZSkpO1xuXG52YXIgc3RyaW5nVG9QYXRoID0gKGlucHV0KSA9PiB7XHJcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgIGlucHV0LnJlcGxhY2UoL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nLCAobWF0Y2gsIG1hdGhOdW1iZXIsIG1hdGhRdW90ZSwgb3JpZ2luYWxTdHJpbmcpID0+IHtcclxuICAgICAgICByZXN1bHQucHVzaChtYXRoUXVvdGVcclxuICAgICAgICAgICAgPyBvcmlnaW5hbFN0cmluZy5yZXBsYWNlKC9cXFxcKFxcXFwpPy9nLCAnJDEnKVxyXG4gICAgICAgICAgICA6IG1hdGhOdW1iZXIgfHwgbWF0Y2gpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59O1xuXG5mdW5jdGlvbiBzZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSkge1xyXG4gICAgbGV0IGluZGV4ID0gLTE7XHJcbiAgICBjb25zdCB0ZW1wUGF0aCA9IGlzS2V5KHBhdGgpID8gW3BhdGhdIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xyXG4gICAgY29uc3QgbGVuZ3RoID0gdGVtcFBhdGgubGVuZ3RoO1xyXG4gICAgY29uc3QgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcclxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XHJcbiAgICAgICAgY29uc3Qga2V5ID0gdGVtcFBhdGhbaW5kZXhdO1xyXG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IHZhbHVlO1xyXG4gICAgICAgIGlmIChpbmRleCAhPT0gbGFzdEluZGV4KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9ialZhbHVlID0gb2JqZWN0W2tleV07XHJcbiAgICAgICAgICAgIG5ld1ZhbHVlID1cclxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0FycmF5KG9ialZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgID8gb2JqVmFsdWVcclxuICAgICAgICAgICAgICAgICAgICA6ICFpc05hTigrdGVtcFBhdGhbaW5kZXggKyAxXSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBvYmplY3Rba2V5XSA9IG5ld1ZhbHVlO1xyXG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iamVjdDtcclxufVxuXG52YXIgdHJhbnNmb3JtVG9OZXN0T2JqZWN0ID0gKGRhdGEpID0+IE9iamVjdC5lbnRyaWVzKGRhdGEpLnJlZHVjZSgocHJldmlvdXMsIFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgaWYgKCFpc0tleShrZXkpKSB7XHJcbiAgICAgICAgc2V0KHByZXZpb3VzLCBrZXksIHZhbHVlKTtcclxuICAgICAgICByZXR1cm4gcHJldmlvdXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2aW91cyksIHsgW2tleV06IHZhbHVlIH0pO1xyXG59LCB7fSk7XG5cbnZhciBpc1VuZGVmaW5lZCA9ICh2YWwpID0+IHZhbCA9PT0gdW5kZWZpbmVkO1xuXG52YXIgdW5pcXVlID0gKHZhbHVlKSA9PiB2YWx1ZS5maWx0ZXIoQm9vbGVhbik7XG5cbnZhciBnZXQgPSAob2JqLCBwYXRoLCBkZWZhdWx0VmFsdWUpID0+IHtcclxuICAgIGNvbnN0IHJlc3VsdCA9IHVuaXF1ZShwYXRoLnNwbGl0KC9bLFtcXF0uXSs/LykpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IChpc051bGxPclVuZGVmaW5lZChyZXN1bHQpID8gcmVzdWx0IDogcmVzdWx0W2tleV0pLCBvYmopO1xyXG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHJlc3VsdCkgfHwgcmVzdWx0ID09PSBvYmpcclxuICAgICAgICA/IGlzVW5kZWZpbmVkKG9ialtwYXRoXSlcclxuICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWVcclxuICAgICAgICAgICAgOiBvYmpbcGF0aF1cclxuICAgICAgICA6IHJlc3VsdDtcclxufTtcblxudmFyIGZvY3VzT25FcnJvckZpZWxkID0gKGZpZWxkcywgZmllbGRFcnJvcnMpID0+IHtcclxuICAgIGZvciAoY29uc3Qga2V5IGluIGZpZWxkcykge1xyXG4gICAgICAgIGlmIChnZXQoZmllbGRFcnJvcnMsIGtleSkpIHtcclxuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNba2V5XTtcclxuICAgICAgICAgICAgaWYgKGZpZWxkKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQucmVmLmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQucmVmLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5vcHRpb25zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQub3B0aW9uc1swXS5yZWYuZm9jdXMoKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufTtcblxudmFyIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzID0gKHJlZiwgdmFsaWRhdGVXaXRoU3RhdGVVcGRhdGUpID0+IHtcclxuICAgIGlmIChpc0hUTUxFbGVtZW50KHJlZikgJiYgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMuSU5QVVQsIHZhbGlkYXRlV2l0aFN0YXRlVXBkYXRlKTtcclxuICAgICAgICByZWYucmVtb3ZlRXZlbnRMaXN0ZW5lcihFVkVOVFMuQ0hBTkdFLCB2YWxpZGF0ZVdpdGhTdGF0ZVVwZGF0ZSk7XHJcbiAgICAgICAgcmVmLnJlbW92ZUV2ZW50TGlzdGVuZXIoRVZFTlRTLkJMVVIsIHZhbGlkYXRlV2l0aFN0YXRlVXBkYXRlKTtcclxuICAgIH1cclxufTtcblxuY29uc3QgZGVmYXVsdFJldHVybiA9IHtcclxuICAgIGlzVmFsaWQ6IGZhbHNlLFxyXG4gICAgdmFsdWU6ICcnLFxyXG59O1xyXG52YXIgZ2V0UmFkaW9WYWx1ZSA9IChvcHRpb25zKSA9PiBpc0FycmF5KG9wdGlvbnMpXHJcbiAgICA/IG9wdGlvbnMucmVkdWNlKChwcmV2aW91cywgb3B0aW9uKSA9PiBvcHRpb24gJiYgb3B0aW9uLnJlZi5jaGVja2VkXHJcbiAgICAgICAgPyB7XHJcbiAgICAgICAgICAgIGlzVmFsaWQ6IHRydWUsXHJcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb24ucmVmLnZhbHVlLFxyXG4gICAgICAgIH1cclxuICAgICAgICA6IHByZXZpb3VzLCBkZWZhdWx0UmV0dXJuKVxyXG4gICAgOiBkZWZhdWx0UmV0dXJuO1xuXG52YXIgZ2V0TXVsdGlwbGVTZWxlY3RWYWx1ZSA9IChvcHRpb25zKSA9PiBbLi4ub3B0aW9uc11cclxuICAgIC5maWx0ZXIoKHsgc2VsZWN0ZWQgfSkgPT4gc2VsZWN0ZWQpXHJcbiAgICAubWFwKCh7IHZhbHVlIH0pID0+IHZhbHVlKTtcblxudmFyIGlzUmFkaW9JbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdyYWRpbyc7XG5cbnZhciBpc0ZpbGVJbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdmaWxlJztcblxudmFyIGlzQ2hlY2tCb3hJbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdjaGVja2JveCc7XG5cbnZhciBpc011bHRpcGxlU2VsZWN0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gYCR7U0VMRUNUfS1tdWx0aXBsZWA7XG5cbmNvbnN0IGRlZmF1bHRSZXN1bHQgPSB7XHJcbiAgICB2YWx1ZTogZmFsc2UsXHJcbiAgICBpc1ZhbGlkOiBmYWxzZSxcclxufTtcclxuY29uc3QgdmFsaWRSZXN1bHQgPSB7IHZhbHVlOiB0cnVlLCBpc1ZhbGlkOiB0cnVlIH07XHJcbnZhciBnZXRDaGVja2JveFZhbHVlID0gKG9wdGlvbnMpID0+IHtcclxuICAgIGlmIChpc0FycmF5KG9wdGlvbnMpKSB7XHJcbiAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoID4gMSkge1xyXG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBvcHRpb25zXHJcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChvcHRpb24pID0+IG9wdGlvbiAmJiBvcHRpb24ucmVmLmNoZWNrZWQpXHJcbiAgICAgICAgICAgICAgICAubWFwKCh7IHJlZjogeyB2YWx1ZSB9IH0pID0+IHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlcywgaXNWYWxpZDogISF2YWx1ZXMubGVuZ3RoIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgY2hlY2tlZCwgdmFsdWUsIGF0dHJpYnV0ZXMgfSA9IG9wdGlvbnNbMF0ucmVmO1xyXG4gICAgICAgIHJldHVybiBjaGVja2VkXHJcbiAgICAgICAgICAgID8gYXR0cmlidXRlcyAmJiAhaXNVbmRlZmluZWQoYXR0cmlidXRlcy52YWx1ZSlcclxuICAgICAgICAgICAgICAgID8gaXNVbmRlZmluZWQodmFsdWUpIHx8IHZhbHVlID09PSAnJ1xyXG4gICAgICAgICAgICAgICAgICAgID8gdmFsaWRSZXN1bHRcclxuICAgICAgICAgICAgICAgICAgICA6IHsgdmFsdWU6IHZhbHVlLCBpc1ZhbGlkOiB0cnVlIH1cclxuICAgICAgICAgICAgICAgIDogdmFsaWRSZXN1bHRcclxuICAgICAgICAgICAgOiBkZWZhdWx0UmVzdWx0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlZmF1bHRSZXN1bHQ7XHJcbn07XG5cbmZ1bmN0aW9uIGdldEZpZWxkVmFsdWUoZmllbGRzUmVmLCBuYW1lLCB1bm1vdW50RmllbGRzU3RhdGVSZWYpIHtcclxuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzUmVmLmN1cnJlbnRbbmFtZV07XHJcbiAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICBjb25zdCB7IHJlZjogeyB2YWx1ZSB9LCByZWYsIH0gPSBmaWVsZDtcclxuICAgICAgICBpZiAoaXNGaWxlSW5wdXQocmVmKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcmVmLmZpbGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNSYWRpb0lucHV0KHJlZikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldFJhZGlvVmFsdWUoZmllbGQub3B0aW9ucykudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc011bHRpcGxlU2VsZWN0KHJlZikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldE11bHRpcGxlU2VsZWN0VmFsdWUocmVmLm9wdGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNDaGVja0JveElucHV0KHJlZikpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldENoZWNrYm94VmFsdWUoZmllbGQub3B0aW9ucykudmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH1cclxuICAgIGlmICh1bm1vdW50RmllbGRzU3RhdGVSZWYpIHtcclxuICAgICAgICByZXR1cm4gdW5tb3VudEZpZWxkc1N0YXRlUmVmLmN1cnJlbnRbbmFtZV07XHJcbiAgICB9XHJcbn1cblxuZnVuY3Rpb24gaXNEZXRhY2hlZChlbGVtZW50KSB7XHJcbiAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICghKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgfHxcclxuICAgICAgICBlbGVtZW50Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaXNEZXRhY2hlZChlbGVtZW50LnBhcmVudE5vZGUpO1xyXG59XG5cbnZhciBpc0VtcHR5T2JqZWN0ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgIU9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG5cbmZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCB1cGRhdGVQYXRoKSB7XHJcbiAgICBjb25zdCBwYXRoID0gdXBkYXRlUGF0aC5zbGljZSgwLCAtMSk7XHJcbiAgICBjb25zdCBsZW5ndGggPSBwYXRoLmxlbmd0aDtcclxuICAgIGxldCBpbmRleCA9IDA7XHJcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcclxuICAgICAgICBvYmplY3QgPSBpc1VuZGVmaW5lZChvYmplY3QpID8gaW5kZXgrKyA6IG9iamVjdFt1cGRhdGVQYXRoW2luZGV4KytdXTtcclxuICAgIH1cclxuICAgIHJldHVybiBvYmplY3Q7XHJcbn1cclxuZnVuY3Rpb24gdW5zZXQob2JqZWN0LCBwYXRoKSB7XHJcbiAgICBjb25zdCB1cGRhdGVQYXRoID0gaXNLZXkocGF0aCkgPyBbcGF0aF0gOiBzdHJpbmdUb1BhdGgocGF0aCk7XHJcbiAgICBjb25zdCBjaGlsZE9iamVjdCA9IHVwZGF0ZVBhdGgubGVuZ3RoID09IDEgPyBvYmplY3QgOiBiYXNlR2V0KG9iamVjdCwgdXBkYXRlUGF0aCk7XHJcbiAgICBjb25zdCBrZXkgPSB1cGRhdGVQYXRoW3VwZGF0ZVBhdGgubGVuZ3RoIC0gMV07XHJcbiAgICBsZXQgcHJldmlvdXNPYmpSZWYgPSB1bmRlZmluZWQ7XHJcbiAgICBpZiAoY2hpbGRPYmplY3QpIHtcclxuICAgICAgICBkZWxldGUgY2hpbGRPYmplY3Rba2V5XTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdXBkYXRlUGF0aC5zbGljZSgwLCAtMSkubGVuZ3RoOyBrKyspIHtcclxuICAgICAgICBsZXQgaW5kZXggPSAtMTtcclxuICAgICAgICBsZXQgb2JqZWN0UmVmID0gdW5kZWZpbmVkO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRocyA9IHVwZGF0ZVBhdGguc2xpY2UoMCwgLShrICsgMSkpO1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRQYXRoc0xlbmd0aCA9IGN1cnJlbnRQYXRocy5sZW5ndGggLSAxO1xyXG4gICAgICAgIGlmIChrID4gMCkge1xyXG4gICAgICAgICAgICBwcmV2aW91c09ialJlZiA9IG9iamVjdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBjdXJyZW50UGF0aHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBjdXJyZW50UGF0aHNbaW5kZXhdO1xyXG4gICAgICAgICAgICBvYmplY3RSZWYgPSBvYmplY3RSZWYgPyBvYmplY3RSZWZbaXRlbV0gOiBvYmplY3RbaXRlbV07XHJcbiAgICAgICAgICAgIGlmIChjdXJyZW50UGF0aHNMZW5ndGggPT09IGluZGV4ICYmXHJcbiAgICAgICAgICAgICAgICAoKGlzT2JqZWN0KG9iamVjdFJlZikgJiYgaXNFbXB0eU9iamVjdChvYmplY3RSZWYpKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgIChpc0FycmF5KG9iamVjdFJlZikgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgIW9iamVjdFJlZi5maWx0ZXIoKGRhdGEpID0+IGlzT2JqZWN0KGRhdGEpICYmICFpc0VtcHR5T2JqZWN0KGRhdGEpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmxlbmd0aCkpKSB7XHJcbiAgICAgICAgICAgICAgICBwcmV2aW91c09ialJlZiA/IGRlbGV0ZSBwcmV2aW91c09ialJlZltpdGVtXSA6IGRlbGV0ZSBvYmplY3RbaXRlbV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcHJldmlvdXNPYmpSZWYgPSBvYmplY3RSZWY7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG9iamVjdDtcclxufVxuXG5jb25zdCBpc1NhbWVSZWYgPSAoZmllbGRWYWx1ZSwgcmVmKSA9PiBmaWVsZFZhbHVlICYmIGZpZWxkVmFsdWUucmVmID09PSByZWY7XHJcbmZ1bmN0aW9uIGZpbmRSZW1vdmVkRmllbGRBbmRSZW1vdmVMaXN0ZW5lcihmaWVsZHNSZWYsIGhhbmRsZUNoYW5nZSwgZmllbGQsIHVubW91bnRGaWVsZHNTdGF0ZVJlZiwgc2hvdWxkVW5yZWdpc3RlciwgZm9yY2VEZWxldGUpIHtcclxuICAgIGNvbnN0IHsgcmVmLCByZWY6IHsgbmFtZSwgdHlwZSB9LCBtdXRhdGlvbldhdGNoZXIsIH0gPSBmaWVsZDtcclxuICAgIGNvbnN0IGZpZWxkUmVmID0gZmllbGRzUmVmLmN1cnJlbnRbbmFtZV07XHJcbiAgICBpZiAoIXNob3VsZFVucmVnaXN0ZXIpIHtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGdldEZpZWxkVmFsdWUoZmllbGRzUmVmLCBuYW1lLCB1bm1vdW50RmllbGRzU3RhdGVSZWYpO1xyXG4gICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHVubW91bnRGaWVsZHNTdGF0ZVJlZi5jdXJyZW50W25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKCF0eXBlKSB7XHJcbiAgICAgICAgZGVsZXRlIGZpZWxkc1JlZi5jdXJyZW50W25hbWVdO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGlmICgoaXNSYWRpb0lucHV0KHJlZikgfHwgaXNDaGVja0JveElucHV0KHJlZikpICYmIGZpZWxkUmVmKSB7XHJcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSBmaWVsZFJlZjtcclxuICAgICAgICBpZiAoaXNBcnJheShvcHRpb25zKSAmJiBvcHRpb25zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB1bmlxdWUob3B0aW9ucykuZm9yRWFjaCgob3B0aW9uLCBpbmRleCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgeyByZWYsIG11dGF0aW9uV2F0Y2hlciB9ID0gb3B0aW9uO1xyXG4gICAgICAgICAgICAgICAgaWYgKChyZWYgJiYgaXNEZXRhY2hlZChyZWYpICYmIGlzU2FtZVJlZihvcHRpb24sIHJlZikpIHx8IGZvcmNlRGVsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlQWxsRXZlbnRMaXN0ZW5lcnMocmVmLCBoYW5kbGVDaGFuZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChtdXRhdGlvbldhdGNoZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25XYXRjaGVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zZXQob3B0aW9ucywgYFske2luZGV4fV1gKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGlmIChvcHRpb25zICYmICF1bmlxdWUob3B0aW9ucykubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgZmllbGRzUmVmLmN1cnJlbnRbbmFtZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBmaWVsZHNSZWYuY3VycmVudFtuYW1lXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICgoaXNEZXRhY2hlZChyZWYpICYmIGlzU2FtZVJlZihmaWVsZFJlZiwgcmVmKSkgfHwgZm9yY2VEZWxldGUpIHtcclxuICAgICAgICByZW1vdmVBbGxFdmVudExpc3RlbmVycyhyZWYsIGhhbmRsZUNoYW5nZSk7XHJcbiAgICAgICAgaWYgKG11dGF0aW9uV2F0Y2hlcikge1xyXG4gICAgICAgICAgICBtdXRhdGlvbldhdGNoZXIuZGlzY29ubmVjdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgZmllbGRzUmVmLmN1cnJlbnRbbmFtZV07XHJcbiAgICB9XHJcbn1cblxudmFyIGlzU3RyaW5nID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXG5mdW5jdGlvbiBkZWVwTWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcclxuICAgIGlmICghaXNPYmplY3QodGFyZ2V0KSB8fCAhaXNPYmplY3Qoc291cmNlKSkge1xyXG4gICAgICAgIHJldHVybiBzb3VyY2U7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzb3VyY2UpIHtcclxuICAgICAgICBjb25zdCB0YXJnZXRWYWx1ZSA9IHRhcmdldFtrZXldO1xyXG4gICAgICAgIGNvbnN0IHNvdXJjZVZhbHVlID0gc291cmNlW2tleV07XHJcbiAgICAgICAgaWYgKGlzT2JqZWN0KHRhcmdldFZhbHVlKSAmJiBpc09iamVjdChzb3VyY2VWYWx1ZSkpIHtcclxuICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBkZWVwTWVyZ2UodGFyZ2V0VmFsdWUsIHNvdXJjZVZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlVmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRhcmdldDtcclxufVxuXG52YXIgZ2V0RmllbGRzVmFsdWVzID0gKGZpZWxkc1JlZiwgdW5tb3VudEZpZWxkc1N0YXRlUmVmLCBzZWFyY2gpID0+IHtcclxuICAgIGNvbnN0IG91dHB1dCA9IHt9O1xyXG4gICAgZm9yIChjb25zdCBuYW1lIGluIGZpZWxkc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHNlYXJjaCkgfHxcclxuICAgICAgICAgICAgKGlzU3RyaW5nKHNlYXJjaClcclxuICAgICAgICAgICAgICAgID8gbmFtZS5zdGFydHNXaXRoKHNlYXJjaClcclxuICAgICAgICAgICAgICAgIDogaXNBcnJheShzZWFyY2gpICYmIHNlYXJjaC5maW5kKChkYXRhKSA9PiBuYW1lLnN0YXJ0c1dpdGgoZGF0YSkpKSkge1xyXG4gICAgICAgICAgICBvdXRwdXRbbmFtZV0gPSBnZXRGaWVsZFZhbHVlKGZpZWxkc1JlZiwgbmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGRlZXBNZXJnZSh0cmFuc2Zvcm1Ub05lc3RPYmplY3QoKHVubW91bnRGaWVsZHNTdGF0ZVJlZiB8fCB7fSkuY3VycmVudCB8fCB7fSksIHRyYW5zZm9ybVRvTmVzdE9iamVjdChvdXRwdXQpKTtcclxufTtcblxudmFyIGlzU2FtZUVycm9yID0gKGVycm9yLCB7IHR5cGUsIHR5cGVzID0ge30sIG1lc3NhZ2UgfSkgPT4gaXNPYmplY3QoZXJyb3IpICYmXHJcbiAgICBlcnJvci50eXBlID09PSB0eXBlICYmXHJcbiAgICBlcnJvci5tZXNzYWdlID09PSBtZXNzYWdlICYmXHJcbiAgICBPYmplY3Qua2V5cyhlcnJvci50eXBlcyB8fCB7fSkubGVuZ3RoID09PSBPYmplY3Qua2V5cyh0eXBlcykubGVuZ3RoICYmXHJcbiAgICBPYmplY3QuZW50cmllcyhlcnJvci50eXBlcyB8fCB7fSkuZXZlcnkoKFtrZXksIHZhbHVlXSkgPT4gdHlwZXNba2V5XSA9PT0gdmFsdWUpO1xuXG5mdW5jdGlvbiBzaG91bGRSZW5kZXJCYXNlZE9uRXJyb3IoeyBlcnJvcnMsIG5hbWUsIGVycm9yLCB2YWxpZEZpZWxkcywgZmllbGRzV2l0aFZhbGlkYXRpb24sIH0pIHtcclxuICAgIGNvbnN0IGlzRmllbGRWYWxpZCA9IGlzRW1wdHlPYmplY3QoZXJyb3IpO1xyXG4gICAgY29uc3QgaXNGb3JtVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XHJcbiAgICBjb25zdCBjdXJyZW50RmllbGRFcnJvciA9IGdldChlcnJvciwgbmFtZSk7XHJcbiAgICBjb25zdCBleGlzdEZpZWxkRXJyb3IgPSBnZXQoZXJyb3JzLCBuYW1lKTtcclxuICAgIGlmIChpc0ZpZWxkVmFsaWQgJiYgdmFsaWRGaWVsZHMuaGFzKG5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlzRm9ybVZhbGlkICE9PSBpc0ZpZWxkVmFsaWQgfHxcclxuICAgICAgICAoIWlzRm9ybVZhbGlkICYmICFleGlzdEZpZWxkRXJyb3IpIHx8XHJcbiAgICAgICAgKGlzRmllbGRWYWxpZCAmJiBmaWVsZHNXaXRoVmFsaWRhdGlvbi5oYXMobmFtZSkgJiYgIXZhbGlkRmllbGRzLmhhcyhuYW1lKSkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBjdXJyZW50RmllbGRFcnJvciAmJiAhaXNTYW1lRXJyb3IoZXhpc3RGaWVsZEVycm9yLCBjdXJyZW50RmllbGRFcnJvcik7XHJcbn1cblxudmFyIGlzUmVnZXggPSAodmFsdWUpID0+IHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuXG5jb25zdCBpc1ZhbHVlTWVzc2FnZSA9ICh2YWx1ZSkgPT4gaXNPYmplY3QodmFsdWUpICYmICFpc1JlZ2V4KHZhbHVlKTtcclxudmFyIGdldFZhbHVlQW5kTWVzc2FnZSA9ICh2YWxpZGF0aW9uRGF0YSkgPT4gaXNWYWx1ZU1lc3NhZ2UodmFsaWRhdGlvbkRhdGEpXHJcbiAgICA/IHZhbGlkYXRpb25EYXRhXHJcbiAgICA6IHtcclxuICAgICAgICB2YWx1ZTogdmFsaWRhdGlvbkRhdGEsXHJcbiAgICAgICAgbWVzc2FnZTogJycsXHJcbiAgICB9O1xuXG52YXIgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG52YXIgaXNCb29sZWFuID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcblxudmFyIGlzTWVzc2FnZSA9ICh2YWx1ZSkgPT4gaXNTdHJpbmcodmFsdWUpIHx8IChpc09iamVjdCh2YWx1ZSkgJiYgaXNWYWxpZEVsZW1lbnQodmFsdWUpKTtcblxuZnVuY3Rpb24gZ2V0VmFsaWRhdGVFcnJvcihyZXN1bHQsIHJlZiwgdHlwZSA9ICd2YWxpZGF0ZScpIHtcclxuICAgIGlmIChpc01lc3NhZ2UocmVzdWx0KSB8fCAoaXNCb29sZWFuKHJlc3VsdCkgJiYgIXJlc3VsdCkpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB0eXBlLFxyXG4gICAgICAgICAgICBtZXNzYWdlOiBpc01lc3NhZ2UocmVzdWx0KSA/IHJlc3VsdCA6ICcnLFxyXG4gICAgICAgICAgICByZWYsXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxufVxuXG52YXIgYXBwZW5kRXJyb3JzID0gKG5hbWUsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZXJyb3JzLCB0eXBlLCBtZXNzYWdlKSA9PiB7XHJcbiAgICBpZiAodmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XHJcbiAgICAgICAgY29uc3QgZXJyb3IgPSBlcnJvcnNbbmFtZV07XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXJyb3IpLCB7IHR5cGVzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChlcnJvciAmJiBlcnJvci50eXBlcyA/IGVycm9yLnR5cGVzIDoge30pKSwgeyBbdHlwZV06IG1lc3NhZ2UgfHwgdHJ1ZSB9KSB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB7fTtcclxufTtcblxudmFyIHZhbGlkYXRlRmllbGQgPSBhc3luYyAoZmllbGRzUmVmLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIHsgcmVmLCByZWY6IHsgdHlwZSwgdmFsdWUgfSwgb3B0aW9ucywgcmVxdWlyZWQsIG1heExlbmd0aCwgbWluTGVuZ3RoLCBtaW4sIG1heCwgcGF0dGVybiwgdmFsaWRhdGUsIH0sIHVubW91bnRGaWVsZHNTdGF0ZVJlZikgPT4ge1xyXG4gICAgY29uc3QgZmllbGRzID0gZmllbGRzUmVmLmN1cnJlbnQ7XHJcbiAgICBjb25zdCBuYW1lID0gcmVmLm5hbWU7XHJcbiAgICBjb25zdCBlcnJvciA9IHt9O1xyXG4gICAgY29uc3QgaXNSYWRpbyA9IGlzUmFkaW9JbnB1dChyZWYpO1xyXG4gICAgY29uc3QgaXNDaGVja0JveCA9IGlzQ2hlY2tCb3hJbnB1dChyZWYpO1xyXG4gICAgY29uc3QgaXNSYWRpb09yQ2hlY2tib3ggPSBpc1JhZGlvIHx8IGlzQ2hlY2tCb3g7XHJcbiAgICBjb25zdCBpc0VtcHR5ID0gdmFsdWUgPT09ICcnO1xyXG4gICAgY29uc3QgYXBwZW5kRXJyb3JzQ3VycnkgPSBhcHBlbmRFcnJvcnMuYmluZChudWxsLCBuYW1lLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGVycm9yKTtcclxuICAgIGNvbnN0IGdldE1pbk1heE1lc3NhZ2UgPSAoZXhjZWVkTWF4LCBtYXhMZW5ndGhNZXNzYWdlLCBtaW5MZW5ndGhNZXNzYWdlLCBtYXhUeXBlID0gSU5QVVRfVkFMSURBVElPTl9SVUxFUy5tYXhMZW5ndGgsIG1pblR5cGUgPSBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1pbkxlbmd0aCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBleGNlZWRNYXggPyBtYXhMZW5ndGhNZXNzYWdlIDogbWluTGVuZ3RoTWVzc2FnZTtcclxuICAgICAgICBlcnJvcltuYW1lXSA9IE9iamVjdC5hc3NpZ24oeyB0eXBlOiBleGNlZWRNYXggPyBtYXhUeXBlIDogbWluVHlwZSwgbWVzc2FnZSxcclxuICAgICAgICAgICAgcmVmIH0sIChleGNlZWRNYXhcclxuICAgICAgICAgICAgPyBhcHBlbmRFcnJvcnNDdXJyeShtYXhUeXBlLCBtZXNzYWdlKVxyXG4gICAgICAgICAgICA6IGFwcGVuZEVycm9yc0N1cnJ5KG1pblR5cGUsIG1lc3NhZ2UpKSk7XHJcbiAgICB9O1xyXG4gICAgaWYgKHJlcXVpcmVkICYmXHJcbiAgICAgICAgKCghaXNSYWRpbyAmJiAhaXNDaGVja0JveCAmJiAoaXNFbXB0eSB8fCBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSkpKSB8fFxyXG4gICAgICAgICAgICAoaXNCb29sZWFuKHZhbHVlKSAmJiAhdmFsdWUpIHx8XHJcbiAgICAgICAgICAgIChpc0NoZWNrQm94ICYmICFnZXRDaGVja2JveFZhbHVlKG9wdGlvbnMpLmlzVmFsaWQpIHx8XHJcbiAgICAgICAgICAgIChpc1JhZGlvICYmICFnZXRSYWRpb1ZhbHVlKG9wdGlvbnMpLmlzVmFsaWQpKSkge1xyXG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IHJlcXVpcmVkVmFsdWUsIG1lc3NhZ2U6IHJlcXVpcmVkTWVzc2FnZSB9ID0gaXNNZXNzYWdlKHJlcXVpcmVkKVxyXG4gICAgICAgICAgICA/IHsgdmFsdWU6ICEhcmVxdWlyZWQsIG1lc3NhZ2U6IHJlcXVpcmVkIH1cclxuICAgICAgICAgICAgOiBnZXRWYWx1ZUFuZE1lc3NhZ2UocmVxdWlyZWQpO1xyXG4gICAgICAgIGlmIChyZXF1aXJlZFZhbHVlKSB7XHJcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0gT2JqZWN0LmFzc2lnbih7IHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsIG1lc3NhZ2U6IHJlcXVpcmVkTWVzc2FnZSwgcmVmOiBpc1JhZGlvT3JDaGVja2JveFxyXG4gICAgICAgICAgICAgICAgICAgID8gKGZpZWxkc1tuYW1lXS5vcHRpb25zIHx8IFtdKVswXS5yZWZcclxuICAgICAgICAgICAgICAgICAgICA6IHJlZiB9LCBhcHBlbmRFcnJvcnNDdXJyeShJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnJlcXVpcmVkLCByZXF1aXJlZE1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWluKSB8fCAhaXNOdWxsT3JVbmRlZmluZWQobWF4KSkge1xyXG4gICAgICAgIGxldCBleGNlZWRNYXg7XHJcbiAgICAgICAgbGV0IGV4Y2VlZE1pbjtcclxuICAgICAgICBjb25zdCB7IHZhbHVlOiBtYXhWYWx1ZSwgbWVzc2FnZTogbWF4TWVzc2FnZSB9ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1heCk7XHJcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogbWluVmFsdWUsIG1lc3NhZ2U6IG1pbk1lc3NhZ2UgfSA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW4pO1xyXG4gICAgICAgIGlmICh0eXBlID09PSAnbnVtYmVyJyB8fCAoIXR5cGUgJiYgIWlzTmFOKHZhbHVlKSkpIHtcclxuICAgICAgICAgICAgY29uc3QgdmFsdWVOdW1iZXIgPSByZWYudmFsdWVBc051bWJlciB8fCBwYXJzZUZsb2F0KHZhbHVlKTtcclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtYXhWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IHZhbHVlTnVtYmVyID4gbWF4VmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChtaW5WYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4Y2VlZE1pbiA9IHZhbHVlTnVtYmVyIDwgbWluVmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlRGF0ZSA9IHJlZi52YWx1ZUFzRGF0ZSB8fCBuZXcgRGF0ZSh2YWx1ZSk7XHJcbiAgICAgICAgICAgIGlmIChpc1N0cmluZyhtYXhWYWx1ZSkpIHtcclxuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IHZhbHVlRGF0ZSA+IG5ldyBEYXRlKG1heFZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWluVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICBleGNlZWRNaW4gPSB2YWx1ZURhdGUgPCBuZXcgRGF0ZShtaW5WYWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGV4Y2VlZE1heCB8fCBleGNlZWRNaW4pIHtcclxuICAgICAgICAgICAgZ2V0TWluTWF4TWVzc2FnZSghIWV4Y2VlZE1heCwgbWF4TWVzc2FnZSwgbWluTWVzc2FnZSwgSU5QVVRfVkFMSURBVElPTl9SVUxFUy5tYXgsIElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWluKTtcclxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChpc1N0cmluZyh2YWx1ZSkgJiYgIWlzRW1wdHkgJiYgKG1heExlbmd0aCB8fCBtaW5MZW5ndGgpKSB7XHJcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogbWF4TGVuZ3RoVmFsdWUsIG1lc3NhZ2U6IG1heExlbmd0aE1lc3NhZ2UsIH0gPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWF4TGVuZ3RoKTtcclxuICAgICAgICBjb25zdCB7IHZhbHVlOiBtaW5MZW5ndGhWYWx1ZSwgbWVzc2FnZTogbWluTGVuZ3RoTWVzc2FnZSwgfSA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW5MZW5ndGgpO1xyXG4gICAgICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gdmFsdWUudG9TdHJpbmcoKS5sZW5ndGg7XHJcbiAgICAgICAgY29uc3QgZXhjZWVkTWF4ID0gIWlzTnVsbE9yVW5kZWZpbmVkKG1heExlbmd0aFZhbHVlKSAmJiBpbnB1dExlbmd0aCA+IG1heExlbmd0aFZhbHVlO1xyXG4gICAgICAgIGNvbnN0IGV4Y2VlZE1pbiA9ICFpc051bGxPclVuZGVmaW5lZChtaW5MZW5ndGhWYWx1ZSkgJiYgaW5wdXRMZW5ndGggPCBtaW5MZW5ndGhWYWx1ZTtcclxuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xyXG4gICAgICAgICAgICBnZXRNaW5NYXhNZXNzYWdlKCEhZXhjZWVkTWF4LCBtYXhMZW5ndGhNZXNzYWdlLCBtaW5MZW5ndGhNZXNzYWdlKTtcclxuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChwYXR0ZXJuICYmICFpc0VtcHR5KSB7XHJcbiAgICAgICAgY29uc3QgeyB2YWx1ZTogcGF0dGVyblZhbHVlLCBtZXNzYWdlOiBwYXR0ZXJuTWVzc2FnZSB9ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKHBhdHRlcm4pO1xyXG4gICAgICAgIGlmIChpc1JlZ2V4KHBhdHRlcm5WYWx1ZSkgJiYgIXBhdHRlcm5WYWx1ZS50ZXN0KHZhbHVlKSkge1xyXG4gICAgICAgICAgICBlcnJvcltuYW1lXSA9IE9iamVjdC5hc3NpZ24oeyB0eXBlOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sIG1lc3NhZ2U6IHBhdHRlcm5NZXNzYWdlLCByZWYgfSwgYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5wYXR0ZXJuLCBwYXR0ZXJuTWVzc2FnZSkpO1xyXG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHZhbGlkYXRlKSB7XHJcbiAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGdldEZpZWxkVmFsdWUoZmllbGRzUmVmLCBuYW1lLCB1bm1vdW50RmllbGRzU3RhdGVSZWYpO1xyXG4gICAgICAgIGNvbnN0IHZhbGlkYXRlUmVmID0gaXNSYWRpb09yQ2hlY2tib3ggJiYgb3B0aW9ucyA/IG9wdGlvbnNbMF0ucmVmIDogcmVmO1xyXG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHZhbGlkYXRlKSkge1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZShmaWVsZFZhbHVlKTtcclxuICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IGdldFZhbGlkYXRlRXJyb3IocmVzdWx0LCB2YWxpZGF0ZVJlZik7XHJcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZUVycm9yKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcltuYW1lXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmFsaWRhdGVFcnJvciksIGFwcGVuZEVycm9yc0N1cnJ5KElOUFVUX1ZBTElEQVRJT05fUlVMRVMudmFsaWRhdGUsIHZhbGlkYXRlRXJyb3IubWVzc2FnZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsaWRhdGUpKSB7XHJcbiAgICAgICAgICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0ID0ge307XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsaWRhdGVGdW5jdGlvbl0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QodmFsaWRhdGlvblJlc3VsdCkgJiYgIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVSZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZUZ1bmN0aW9uKGZpZWxkVmFsdWUpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IGdldFZhbGlkYXRlRXJyb3IodmFsaWRhdGVSZXN1bHQsIHZhbGlkYXRlUmVmLCBrZXkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2YWxpZGF0ZUVycm9yKSwgYXBwZW5kRXJyb3JzQ3Vycnkoa2V5LCB2YWxpZGF0ZUVycm9yLm1lc3NhZ2UpKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0gdmFsaWRhdGlvblJlc3VsdDtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCFpc0VtcHR5T2JqZWN0KHZhbGlkYXRpb25SZXN1bHQpKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcltuYW1lXSA9IE9iamVjdC5hc3NpZ24oeyByZWY6IHZhbGlkYXRlUmVmIH0sIHZhbGlkYXRpb25SZXN1bHQpO1xyXG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZXJyb3I7XHJcbn07XG5cbnZhciBpc1ByaW1pdGl2ZSA9ICh2YWx1ZSkgPT4gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8ICFpc09iamVjdFR5cGUodmFsdWUpO1xuXG5jb25zdCBnZXRQYXRoID0gKHBhdGgsIHZhbHVlcykgPT4ge1xyXG4gICAgY29uc3QgZ2V0SW5uZXJQYXRoID0gKHZhbHVlLCBrZXksIGlzT2JqZWN0KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGF0aFdpdGhJbmRleCA9IGlzT2JqZWN0ID8gYCR7cGF0aH0uJHtrZXl9YCA6IGAke3BhdGh9WyR7a2V5fV1gO1xyXG4gICAgICAgIHJldHVybiBpc1ByaW1pdGl2ZSh2YWx1ZSkgPyBwYXRoV2l0aEluZGV4IDogZ2V0UGF0aChwYXRoV2l0aEluZGV4LCB2YWx1ZSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKHZhbHVlcylcclxuICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGdldElubmVyUGF0aCh2YWx1ZSwga2V5LCBpc09iamVjdCh2YWx1ZXMpKSlcclxuICAgICAgICAuZmxhdChJbmZpbml0eSk7XHJcbn07XG5cbnZhciBhc3NpZ25XYXRjaEZpZWxkcyA9IChmaWVsZFZhbHVlcywgZmllbGROYW1lLCB3YXRjaEZpZWxkcywgaW5wdXRWYWx1ZSwgaXNTaW5nbGVGaWVsZCkgPT4ge1xyXG4gICAgbGV0IHZhbHVlO1xyXG4gICAgd2F0Y2hGaWVsZHMuYWRkKGZpZWxkTmFtZSk7XHJcbiAgICBpZiAoaXNFbXB0eU9iamVjdChmaWVsZFZhbHVlcykpIHtcclxuICAgICAgICB2YWx1ZSA9IHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHZhbHVlID0gZ2V0KGZpZWxkVmFsdWVzLCBmaWVsZE5hbWUpO1xyXG4gICAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgZ2V0UGF0aChmaWVsZE5hbWUsIHZhbHVlKS5mb3JFYWNoKChuYW1lKSA9PiB3YXRjaEZpZWxkcy5hZGQobmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpc1VuZGVmaW5lZCh2YWx1ZSlcclxuICAgICAgICA/IGlzU2luZ2xlRmllbGRcclxuICAgICAgICAgICAgPyBpbnB1dFZhbHVlXHJcbiAgICAgICAgICAgIDogZ2V0KGlucHV0VmFsdWUsIGZpZWxkTmFtZSlcclxuICAgICAgICA6IHZhbHVlO1xyXG59O1xuXG52YXIgc2tpcFZhbGlkYXRpb24gPSAoeyBpc09uQmx1ciwgaXNPbkNoYW5nZSwgaXNSZVZhbGlkYXRlT25CbHVyLCBpc1JlVmFsaWRhdGVPbkNoYW5nZSwgaXNCbHVyRXZlbnQsIGlzU3VibWl0dGVkLCBpc09uQWxsLCB9KSA9PiB7XHJcbiAgICBpZiAoaXNPbkFsbCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGlzU3VibWl0dGVkID8gaXNSZVZhbGlkYXRlT25CbHVyIDogaXNPbkJsdXIpIHtcclxuICAgICAgICByZXR1cm4gIWlzQmx1ckV2ZW50O1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyBpc1JlVmFsaWRhdGVPbkNoYW5nZSA6IGlzT25DaGFuZ2UpIHtcclxuICAgICAgICByZXR1cm4gaXNCbHVyRXZlbnQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdHJ1ZTtcclxufTtcblxudmFyIGdldEZpZWxkQXJyYXlQYXJlbnROYW1lID0gKG5hbWUpID0+IG5hbWUuc3Vic3RyaW5nKDAsIG5hbWUuaW5kZXhPZignWycpKTtcblxuZnVuY3Rpb24gZGVlcEVxdWFsKG9iamVjdDEgPSBbXSwgb2JqZWN0MiA9IFtdKSB7XHJcbiAgICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iamVjdDEpO1xyXG4gICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmplY3QyKTtcclxuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMxKSB7XHJcbiAgICAgICAgY29uc3QgdmFsMSA9IG9iamVjdDFba2V5XTtcclxuICAgICAgICBjb25zdCB2YWwyID0gb2JqZWN0MltrZXldO1xyXG4gICAgICAgIGlmICgoaXNPYmplY3QodmFsMSkgfHwgaXNBcnJheSh2YWwxKSkgJiYgKGlzT2JqZWN0KHZhbDIpIHx8IGlzQXJyYXkodmFsMikpXHJcbiAgICAgICAgICAgID8gIWRlZXBFcXVhbCh2YWwxLCB2YWwyKVxyXG4gICAgICAgICAgICA6IHZhbDEgIT09IHZhbDIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XG5cbmNvbnN0IGlzTWF0Y2hGaWVsZEFycmF5TmFtZSA9IChuYW1lLCBzZWFyY2hOYW1lKSA9PiBSZWdFeHAoYF4ke3NlYXJjaE5hbWV9W1xcXFxkK11gLnJlcGxhY2UoL1xcWy9nLCAnXFxcXFsnKS5yZXBsYWNlKC9cXF0vZywgJ1xcXFxdJykpLnRlc3QobmFtZSk7XHJcbnZhciBpc05hbWVJbkZpZWxkQXJyYXkgPSAobmFtZXMsIG5hbWUpID0+IFsuLi5uYW1lc10uc29tZSgoY3VycmVudCkgPT4gaXNNYXRjaEZpZWxkQXJyYXlOYW1lKG5hbWUsIGN1cnJlbnQpKTtcblxudmFyIGlzU2VsZWN0SW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSBgJHtTRUxFQ1R9LW9uZWA7XG5cbmZ1bmN0aW9uIG9uRG9tUmVtb3ZlKGVsZW1lbnQsIG9uRGV0YWNoQ2FsbGJhY2spIHtcclxuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKCkgPT4ge1xyXG4gICAgICAgIGlmIChpc0RldGFjaGVkKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcclxuICAgICAgICAgICAgb25EZXRhY2hDYWxsYmFjaygpO1xyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgb2JzZXJ2ZXIub2JzZXJ2ZSh3aW5kb3cuZG9jdW1lbnQsIHtcclxuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXHJcbiAgICAgICAgc3VidHJlZTogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIG9ic2VydmVyO1xyXG59XG5cbnZhciBtb2RlQ2hlY2tlciA9IChtb2RlKSA9PiAoe1xyXG4gICAgaXNPblN1Ym1pdDogIW1vZGUgfHwgbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uU3VibWl0LFxyXG4gICAgaXNPbkJsdXI6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vbkJsdXIsXHJcbiAgICBpc09uQ2hhbmdlOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25DaGFuZ2UsXHJcbiAgICBpc09uQWxsOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUuYWxsLFxyXG59KTtcblxudmFyIGlzUmFkaW9PckNoZWNrYm94RnVuY3Rpb24gPSAocmVmKSA9PiBpc1JhZGlvSW5wdXQocmVmKSB8fCBpc0NoZWNrQm94SW5wdXQocmVmKTtcblxuY29uc3QgaXNXaW5kb3dVbmRlZmluZWQgPSB0eXBlb2Ygd2luZG93ID09PSBVTkRFRklORUQ7XHJcbmNvbnN0IGlzV2ViID0gdHlwZW9mIGRvY3VtZW50ICE9PSBVTkRFRklORUQgJiZcclxuICAgICFpc1dpbmRvd1VuZGVmaW5lZCAmJlxyXG4gICAgIWlzVW5kZWZpbmVkKHdpbmRvdy5IVE1MRWxlbWVudCk7XHJcbmNvbnN0IGlzUHJveHlFbmFibGVkID0gaXNXZWIgPyAnUHJveHknIGluIHdpbmRvdyA6IHR5cGVvZiBQcm94eSAhPT0gVU5ERUZJTkVEO1xyXG5mdW5jdGlvbiB1c2VGb3JtKHsgbW9kZSA9IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCwgcmVWYWxpZGF0ZU1vZGUgPSBWQUxJREFUSU9OX01PREUub25DaGFuZ2UsIHJlc29sdmVyLCBjb250ZXh0LCBkZWZhdWx0VmFsdWVzID0ge30sIHNob3VsZEZvY3VzRXJyb3IgPSB0cnVlLCBzaG91bGRVbnJlZ2lzdGVyID0gdHJ1ZSwgY3JpdGVyaWFNb2RlLCB9ID0ge30pIHtcclxuICAgIGNvbnN0IGZpZWxkc1JlZiA9IHVzZVJlZih7fSk7XHJcbiAgICBjb25zdCBlcnJvcnNSZWYgPSB1c2VSZWYoe30pO1xyXG4gICAgY29uc3QgdG91Y2hlZEZpZWxkc1JlZiA9IHVzZVJlZih7fSk7XHJcbiAgICBjb25zdCBmaWVsZEFycmF5RGVmYXVsdFZhbHVlcyA9IHVzZVJlZih7fSk7XHJcbiAgICBjb25zdCBkaXJ0eUZpZWxkc1JlZiA9IHVzZVJlZih7fSk7XHJcbiAgICBjb25zdCB3YXRjaEZpZWxkc1JlZiA9IHVzZVJlZihuZXcgU2V0KCkpO1xyXG4gICAgY29uc3Qgd2F0Y2hGaWVsZHNIb29rUmVmID0gdXNlUmVmKHt9KTtcclxuICAgIGNvbnN0IHdhdGNoRmllbGRzSG9va1JlbmRlclJlZiA9IHVzZVJlZih7fSk7XHJcbiAgICBjb25zdCBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZiA9IHVzZVJlZihuZXcgU2V0KCkpO1xyXG4gICAgY29uc3QgdmFsaWRGaWVsZHNSZWYgPSB1c2VSZWYobmV3IFNldCgpKTtcclxuICAgIGNvbnN0IGlzVmFsaWRSZWYgPSB1c2VSZWYodHJ1ZSk7XHJcbiAgICBjb25zdCBkZWZhdWx0VmFsdWVzUmVmID0gdXNlUmVmKGRlZmF1bHRWYWx1ZXMpO1xyXG4gICAgY29uc3QgZGVmYXVsdFZhbHVlc0F0UmVuZGVyUmVmID0gdXNlUmVmKHt9KTtcclxuICAgIGNvbnN0IGlzVW5Nb3VudCA9IHVzZVJlZihmYWxzZSk7XHJcbiAgICBjb25zdCBpc1dhdGNoQWxsUmVmID0gdXNlUmVmKGZhbHNlKTtcclxuICAgIGNvbnN0IGlzU3VibWl0dGVkUmVmID0gdXNlUmVmKGZhbHNlKTtcclxuICAgIGNvbnN0IGlzRGlydHlSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gICAgY29uc3Qgc3VibWl0Q291bnRSZWYgPSB1c2VSZWYoMCk7XHJcbiAgICBjb25zdCBpc1N1Ym1pdHRpbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xyXG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlUmVmID0gdXNlUmVmKCk7XHJcbiAgICBjb25zdCB1bm1vdW50RmllbGRzU3RhdGVSZWYgPSB1c2VSZWYoe30pO1xyXG4gICAgY29uc3QgcmVzZXRGaWVsZEFycmF5RnVuY3Rpb25SZWYgPSB1c2VSZWYoe30pO1xyXG4gICAgY29uc3QgY29udGV4dFJlZiA9IHVzZVJlZihjb250ZXh0KTtcclxuICAgIGNvbnN0IHJlc29sdmVyUmVmID0gdXNlUmVmKHJlc29sdmVyKTtcclxuICAgIGNvbnN0IGZpZWxkQXJyYXlOYW1lc1JlZiA9IHVzZVJlZihuZXcgU2V0KCkpO1xyXG4gICAgY29uc3QgWywgcmVuZGVyXSA9IHVzZVN0YXRlKCk7XHJcbiAgICBjb25zdCBtb2RlUmVmID0gdXNlUmVmKG1vZGVDaGVja2VyKG1vZGUpKTtcclxuICAgIGNvbnN0IHsgY3VycmVudDogeyBpc09uU3VibWl0LCBpc09uQWxsIH0sIH0gPSBtb2RlUmVmO1xyXG4gICAgY29uc3QgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEgPSBjcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGw7XHJcbiAgICBjb25zdCByZWFkRm9ybVN0YXRlUmVmID0gdXNlUmVmKHtcclxuICAgICAgICBpc0RpcnR5OiAhaXNQcm94eUVuYWJsZWQsXHJcbiAgICAgICAgZGlydHlGaWVsZHM6ICFpc1Byb3h5RW5hYmxlZCxcclxuICAgICAgICBpc1N1Ym1pdHRlZDogaXNPblN1Ym1pdCxcclxuICAgICAgICBzdWJtaXRDb3VudDogIWlzUHJveHlFbmFibGVkLFxyXG4gICAgICAgIHRvdWNoZWQ6ICFpc1Byb3h5RW5hYmxlZCxcclxuICAgICAgICBpc1N1Ym1pdHRpbmc6ICFpc1Byb3h5RW5hYmxlZCxcclxuICAgICAgICBpc1ZhbGlkOiAhaXNQcm94eUVuYWJsZWQsXHJcbiAgICB9KTtcclxuICAgIGNvbnN0IHsgY3VycmVudDogeyBpc09uQmx1cjogaXNSZVZhbGlkYXRlT25CbHVyLCBpc09uQ2hhbmdlOiBpc1JlVmFsaWRhdGVPbkNoYW5nZSB9LCB9ID0gdXNlUmVmKG1vZGVDaGVja2VyKHJlVmFsaWRhdGVNb2RlKSk7XHJcbiAgICBjb250ZXh0UmVmLmN1cnJlbnQgPSBjb250ZXh0O1xyXG4gICAgcmVzb2x2ZXJSZWYuY3VycmVudCA9IHJlc29sdmVyO1xyXG4gICAgY29uc3QgcmVSZW5kZXIgPSB1c2VDYWxsYmFjaygoKSA9PiAhaXNVbk1vdW50LmN1cnJlbnQgJiYgcmVuZGVyKHt9KSwgW10pO1xyXG4gICAgY29uc3Qgc2hvdWxkUmVuZGVyQmFzZU9uRXJyb3IgPSB1c2VDYWxsYmFjaygobmFtZSwgZXJyb3IsIHNob3VsZFJlbmRlciA9IGZhbHNlKSA9PiB7XHJcbiAgICAgICAgbGV0IHNob3VsZFJlUmVuZGVyID0gc2hvdWxkUmVuZGVyIHx8XHJcbiAgICAgICAgICAgIHNob3VsZFJlbmRlckJhc2VkT25FcnJvcih7XHJcbiAgICAgICAgICAgICAgICBlcnJvcnM6IGVycm9yc1JlZi5jdXJyZW50LFxyXG4gICAgICAgICAgICAgICAgZXJyb3IsXHJcbiAgICAgICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAgICAgdmFsaWRGaWVsZHM6IHZhbGlkRmllbGRzUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgICAgICAgICBmaWVsZHNXaXRoVmFsaWRhdGlvbjogZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNFcnJvciA9IGdldChlcnJvcnNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICAgICAgaWYgKGlzRW1wdHlPYmplY3QoZXJyb3IpKSB7XHJcbiAgICAgICAgICAgIGlmIChmaWVsZHNXaXRoVmFsaWRhdGlvblJlZi5jdXJyZW50LmhhcyhuYW1lKSB8fCByZXNvbHZlclJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZEZpZWxkc1JlZi5jdXJyZW50LmFkZChuYW1lKTtcclxuICAgICAgICAgICAgICAgIHNob3VsZFJlUmVuZGVyID0gc2hvdWxkUmVSZW5kZXIgfHwgcHJldmlvdXNFcnJvcjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlcnJvcnNSZWYuY3VycmVudCA9IHVuc2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhbGlkRmllbGRzUmVmLmN1cnJlbnQuZGVsZXRlKG5hbWUpO1xyXG4gICAgICAgICAgICBzaG91bGRSZVJlbmRlciA9XHJcbiAgICAgICAgICAgICAgICBzaG91bGRSZVJlbmRlciB8fFxyXG4gICAgICAgICAgICAgICAgICAgICFwcmV2aW91c0Vycm9yIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIWlzU2FtZUVycm9yKHByZXZpb3VzRXJyb3IsIGVycm9yW25hbWVdKTtcclxuICAgICAgICAgICAgc2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lLCBlcnJvcltuYW1lXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRSZVJlbmRlciAmJiAhaXNOdWxsT3JVbmRlZmluZWQoc2hvdWxkUmVuZGVyKSkge1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCBzZXRGaWVsZFZhbHVlID0gdXNlQ2FsbGJhY2soKHsgcmVmLCBvcHRpb25zIH0sIHJhd1ZhbHVlKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBpc1dlYiAmJiBpc0hUTUxFbGVtZW50KHJlZikgJiYgaXNOdWxsT3JVbmRlZmluZWQocmF3VmFsdWUpXHJcbiAgICAgICAgICAgID8gJydcclxuICAgICAgICAgICAgOiByYXdWYWx1ZTtcclxuICAgICAgICBpZiAoaXNSYWRpb0lucHV0KHJlZikgJiYgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBvcHRpb25zLmZvckVhY2goKHsgcmVmOiByYWRpb1JlZiB9KSA9PiAocmFkaW9SZWYuY2hlY2tlZCA9IHJhZGlvUmVmLnZhbHVlID09PSB2YWx1ZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChpc0ZpbGVJbnB1dChyZWYpICYmICFpc1N0cmluZyh2YWx1ZSkpIHtcclxuICAgICAgICAgICAgcmVmLmZpbGVzID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGlzTXVsdGlwbGVTZWxlY3QocmVmKSkge1xyXG4gICAgICAgICAgICBbLi4ucmVmLm9wdGlvbnNdLmZvckVhY2goKHNlbGVjdFJlZikgPT4gKHNlbGVjdFJlZi5zZWxlY3RlZCA9IHZhbHVlLmluY2x1ZGVzKHNlbGVjdFJlZi52YWx1ZSkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXNDaGVja0JveElucHV0KHJlZikgJiYgb3B0aW9ucykge1xyXG4gICAgICAgICAgICBvcHRpb25zLmxlbmd0aCA+IDFcclxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5mb3JFYWNoKCh7IHJlZjogY2hlY2tib3hSZWYgfSkgPT4gKGNoZWNrYm94UmVmLmNoZWNrZWQgPSBTdHJpbmcodmFsdWUpLmluY2x1ZGVzKGNoZWNrYm94UmVmLnZhbHVlKSkpXHJcbiAgICAgICAgICAgICAgICA6IChvcHRpb25zWzBdLnJlZi5jaGVja2VkID0gISF2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWYudmFsdWUgPSB2YWx1ZTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCBzZXREaXJ0eSA9IHVzZUNhbGxiYWNrKChuYW1lKSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBpc0RpcnR5LCBkaXJ0eUZpZWxkcyB9ID0gcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50O1xyXG4gICAgICAgIGlmICghZmllbGRzUmVmLmN1cnJlbnRbbmFtZV0gfHwgKCFpc0RpcnR5ICYmICFkaXJ0eUZpZWxkcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBpc0ZpZWxkRGlydHkgPSBkZWZhdWx0VmFsdWVzQXRSZW5kZXJSZWYuY3VycmVudFtuYW1lXSAhPT1cclxuICAgICAgICAgICAgZ2V0RmllbGRWYWx1ZShmaWVsZHNSZWYsIG5hbWUsIHVubW91bnRGaWVsZHNTdGF0ZVJlZik7XHJcbiAgICAgICAgY29uc3QgaXNEaXJ0eUZpZWxkRXhpc3QgPSBnZXQoZGlydHlGaWVsZHNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICAgICAgY29uc3QgaXNGaWVsZEFycmF5ID0gaXNOYW1lSW5GaWVsZEFycmF5KGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICBjb25zdCBwcmV2aW91c0lzRGlydHkgPSBpc0RpcnR5UmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgaWYgKGlzRmllbGREaXJ0eSkge1xyXG4gICAgICAgICAgICBzZXQoZGlydHlGaWVsZHNSZWYuY3VycmVudCwgbmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB1bnNldChkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaXNEaXJ0eVJlZi5jdXJyZW50ID1cclxuICAgICAgICAgICAgKGlzRmllbGRBcnJheSAmJlxyXG4gICAgICAgICAgICAgICAgIWRlZXBFcXVhbChnZXQoZ2V0VmFsdWVzKCksIGdldEZpZWxkQXJyYXlQYXJlbnROYW1lKG5hbWUpKSwgZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgZ2V0RmllbGRBcnJheVBhcmVudE5hbWUobmFtZSkpKSkgfHxcclxuICAgICAgICAgICAgICAgICFpc0VtcHR5T2JqZWN0KGRpcnR5RmllbGRzUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIHJldHVybiAoKGlzRGlydHkgJiYgcHJldmlvdXNJc0RpcnR5ICE9PSBpc0RpcnR5UmVmLmN1cnJlbnQpIHx8XHJcbiAgICAgICAgICAgIChkaXJ0eUZpZWxkcyAmJiBpc0RpcnR5RmllbGRFeGlzdCAhPT0gZ2V0KGRpcnR5RmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpKSk7XHJcbiAgICB9LCBbXSk7XHJcbiAgICBjb25zdCBleGVjdXRlVmFsaWRhdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jIChuYW1lLCBza2lwUmVSZW5kZXIpID0+IHtcclxuICAgICAgICBpZiAoZmllbGRzUmVmLmN1cnJlbnRbbmFtZV0pIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBhd2FpdCB2YWxpZGF0ZUZpZWxkKGZpZWxkc1JlZiwgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGZpZWxkc1JlZi5jdXJyZW50W25hbWVdLCB1bm1vdW50RmllbGRzU3RhdGVSZWYpO1xyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXJCYXNlT25FcnJvcihuYW1lLCBlcnJvciwgc2tpcFJlUmVuZGVyID8gbnVsbCA6IGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzRW1wdHlPYmplY3QoZXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9LCBbc2hvdWxkUmVuZGVyQmFzZU9uRXJyb3IsIGlzVmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhXSk7XHJcbiAgICBjb25zdCBleGVjdXRlU2NoZW1hT3JSZXNvbHZlclZhbGlkYXRpb24gPSB1c2VDYWxsYmFjayhhc3luYyAocGF5bG9hZCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSBhd2FpdCByZXNvbHZlclJlZi5jdXJyZW50KGdldFZhbHVlcygpLCBjb250ZXh0UmVmLmN1cnJlbnQsIGlzVmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKTtcclxuICAgICAgICBjb25zdCBwcmV2aW91c0Zvcm1Jc1ZhbGlkID0gaXNWYWxpZFJlZi5jdXJyZW50O1xyXG4gICAgICAgIGlzVmFsaWRSZWYuY3VycmVudCA9IGlzRW1wdHlPYmplY3QoZXJyb3JzKTtcclxuICAgICAgICBpZiAoaXNBcnJheShwYXlsb2FkKSkge1xyXG4gICAgICAgICAgICBjb25zdCBpc0lucHV0c1ZhbGlkID0gcGF5bG9hZFxyXG4gICAgICAgICAgICAgICAgLm1hcCgobmFtZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBnZXQoZXJyb3JzLCBuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldChlcnJvcnNSZWYuY3VycmVudCwgbmFtZSwgZXJyb3IpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdW5zZXQoZXJyb3JzUmVmLmN1cnJlbnQsIG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuICFlcnJvcjtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAgIC5ldmVyeShCb29sZWFuKTtcclxuICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIGlzSW5wdXRzVmFsaWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IGdldChlcnJvcnMsIHBheWxvYWQpO1xyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXJCYXNlT25FcnJvcihwYXlsb2FkLCAoZXJyb3IgPyB7IFtwYXlsb2FkXTogZXJyb3IgfSA6IHt9KSwgcHJldmlvdXNGb3JtSXNWYWxpZCAhPT0gaXNWYWxpZFJlZi5jdXJyZW50KTtcclxuICAgICAgICAgICAgcmV0dXJuICFlcnJvcjtcclxuICAgICAgICB9XHJcbiAgICB9LCBbc2hvdWxkUmVuZGVyQmFzZU9uRXJyb3IsIGlzVmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhXSk7XHJcbiAgICBjb25zdCB0cmlnZ2VyID0gdXNlQ2FsbGJhY2soYXN5bmMgKG5hbWUpID0+IHtcclxuICAgICAgICBjb25zdCBmaWVsZHMgPSBuYW1lIHx8IE9iamVjdC5rZXlzKGZpZWxkc1JlZi5jdXJyZW50KTtcclxuICAgICAgICBpZiAocmVzb2x2ZXJSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVNjaGVtYU9yUmVzb2x2ZXJWYWxpZGF0aW9uKGZpZWxkcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc0FycmF5KGZpZWxkcykpIHtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUHJvbWlzZS5hbGwoZmllbGRzLm1hcChhc3luYyAoZGF0YSkgPT4gYXdhaXQgZXhlY3V0ZVZhbGlkYXRpb24oZGF0YSwgdHJ1ZSkpKTtcclxuICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5ldmVyeShCb29sZWFuKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IGV4ZWN1dGVWYWxpZGF0aW9uKGZpZWxkcyk7XHJcbiAgICB9LCBbZXhlY3V0ZVNjaGVtYU9yUmVzb2x2ZXJWYWxpZGF0aW9uLCBleGVjdXRlVmFsaWRhdGlvbl0pO1xyXG4gICAgY29uc3Qgc2V0SW50ZXJuYWxWYWx1ZXMgPSB1c2VDYWxsYmFjaygobmFtZSwgdmFsdWUsIHsgc2hvdWxkRGlydHksIHNob3VsZFZhbGlkYXRlIH0pID0+IHtcclxuICAgICAgICBnZXRQYXRoKG5hbWUsIHZhbHVlKS5mb3JFYWNoKChmaWVsZE5hbWUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHt9O1xyXG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1JlZi5jdXJyZW50W2ZpZWxkTmFtZV07XHJcbiAgICAgICAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgc2V0KGRhdGEsIG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgICAgIHNldEZpZWxkVmFsdWUoZmllbGQsIGdldChkYXRhLCBmaWVsZE5hbWUpKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaG91bGREaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldERpcnR5KGZpZWxkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkVmFsaWRhdGUpIHtcclxuICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyKGZpZWxkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0sIFt0cmlnZ2VyLCBzZXRGaWVsZFZhbHVlLCBzZXREaXJ0eV0pO1xyXG4gICAgY29uc3Qgc2V0SW50ZXJuYWxWYWx1ZSA9IHVzZUNhbGxiYWNrKChuYW1lLCB2YWx1ZSwgY29uZmlnKSA9PiB7XHJcbiAgICAgICAgaWYgKGZpZWxkc1JlZi5jdXJyZW50W25hbWVdKSB7XHJcbiAgICAgICAgICAgIHNldEZpZWxkVmFsdWUoZmllbGRzUmVmLmN1cnJlbnRbbmFtZV0sIHZhbHVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZy5zaG91bGREaXJ0eSAmJiBzZXREaXJ0eShuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWlzUHJpbWl0aXZlKHZhbHVlKSkge1xyXG4gICAgICAgICAgICBzZXRJbnRlcm5hbFZhbHVlcyhuYW1lLCB2YWx1ZSwgY29uZmlnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFzaG91bGRVbnJlZ2lzdGVyKSB7XHJcbiAgICAgICAgICAgIHVubW91bnRGaWVsZHNTdGF0ZVJlZi5jdXJyZW50W25hbWVdID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSwgW3NldERpcnR5LCBzZXRGaWVsZFZhbHVlLCBzZXRJbnRlcm5hbFZhbHVlc10pO1xyXG4gICAgY29uc3QgaXNGaWVsZFdhdGNoZWQgPSAobmFtZSkgPT4gaXNXYXRjaEFsbFJlZi5jdXJyZW50IHx8XHJcbiAgICAgICAgd2F0Y2hGaWVsZHNSZWYuY3VycmVudC5oYXMobmFtZSkgfHxcclxuICAgICAgICB3YXRjaEZpZWxkc1JlZi5jdXJyZW50LmhhcygobmFtZS5tYXRjaCgvXFx3Ky8pIHx8IFtdKVswXSk7XHJcbiAgICBjb25zdCByZW5kZXJXYXRjaGVkSW5wdXRzID0gKG5hbWUsIGZvdW5kID0gdHJ1ZSkgPT4ge1xyXG4gICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh3YXRjaEZpZWxkc0hvb2tSZWYuY3VycmVudCkpIHtcclxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gd2F0Y2hGaWVsZHNIb29rUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmIChuYW1lID09PSAnJyB8fFxyXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoRmllbGRzSG9va1JlZi5jdXJyZW50W2tleV0uaGFzKG5hbWUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgd2F0Y2hGaWVsZHNIb29rUmVmLmN1cnJlbnRba2V5XS5oYXMoZ2V0RmllbGRBcnJheVBhcmVudE5hbWUobmFtZSkpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgIXdhdGNoRmllbGRzSG9va1JlZi5jdXJyZW50W2tleV0uc2l6ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHdhdGNoRmllbGRzSG9va1JlbmRlclJlZi5jdXJyZW50W2tleV0oKTtcclxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmb3VuZDtcclxuICAgIH07XHJcbiAgICBmdW5jdGlvbiBzZXRWYWx1ZShuYW1lLCB2YWx1ZSwgY29uZmlnID0ge30pIHtcclxuICAgICAgICBjb25zdCBzaG91bGRSZW5kZXIgPSBzZXRJbnRlcm5hbFZhbHVlKG5hbWUsIHZhbHVlLCBjb25maWcpIHx8XHJcbiAgICAgICAgICAgIGlzRmllbGRXYXRjaGVkKG5hbWUpO1xyXG4gICAgICAgIHJlbmRlcldhdGNoZWRJbnB1dHMobmFtZSk7XHJcbiAgICAgICAgaWYgKHNob3VsZFJlbmRlcikge1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29uZmlnLnNob3VsZFZhbGlkYXRlKSB7XHJcbiAgICAgICAgICAgIHRyaWdnZXIobmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaGFuZGxlQ2hhbmdlUmVmLmN1cnJlbnQgPSBoYW5kbGVDaGFuZ2VSZWYuY3VycmVudFxyXG4gICAgICAgID8gaGFuZGxlQ2hhbmdlUmVmLmN1cnJlbnRcclxuICAgICAgICA6IGFzeW5jICh7IHR5cGUsIHRhcmdldCB9KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0YXJnZXQubmFtZTtcclxuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNSZWYuY3VycmVudFtuYW1lXTtcclxuICAgICAgICAgICAgbGV0IGVycm9yO1xyXG4gICAgICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmx1ckV2ZW50ID0gdHlwZSA9PT0gRVZFTlRTLkJMVVI7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRTa2lwVmFsaWRhdGlvbiA9ICFpc09uQWxsICYmXHJcbiAgICAgICAgICAgICAgICAgICAgc2tpcFZhbGlkYXRpb24oT2JqZWN0LmFzc2lnbih7IGlzQmx1ckV2ZW50LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1JlVmFsaWRhdGVPbkNoYW5nZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNSZVZhbGlkYXRlT25CbHVyLCBpc1N1Ym1pdHRlZDogaXNTdWJtaXR0ZWRSZWYuY3VycmVudCB9LCBtb2RlUmVmLmN1cnJlbnQpKTtcclxuICAgICAgICAgICAgICAgIGxldCBzaG91bGRSZW5kZXIgPSBzZXREaXJ0eShuYW1lKSB8fCBpc0ZpZWxkV2F0Y2hlZChuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCAmJlxyXG4gICAgICAgICAgICAgICAgICAgICFnZXQodG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC50b3VjaGVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTa2lwVmFsaWRhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcldhdGNoZWRJbnB1dHMobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNob3VsZFJlbmRlciAmJiByZVJlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9ycyB9ID0gYXdhaXQgcmVzb2x2ZXJSZWYuY3VycmVudChnZXRWYWx1ZXMoKSwgY29udGV4dFJlZi5jdXJyZW50LCBpc1ZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGb3JtSXNWYWxpZCA9IGlzVmFsaWRSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkUmVmLmN1cnJlbnQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSAoZ2V0KGVycm9ycywgbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IFtuYW1lXTogZ2V0KGVycm9ycywgbmFtZSkgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9KTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNGb3JtSXNWYWxpZCAhPT0gaXNWYWxpZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3VsZFJlbmRlciA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IgPSBhd2FpdCB2YWxpZGF0ZUZpZWxkKGZpZWxkc1JlZiwgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGZpZWxkLCB1bm1vdW50RmllbGRzU3RhdGVSZWYpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmVuZGVyV2F0Y2hlZElucHV0cyhuYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUmVuZGVyQmFzZU9uRXJyb3IobmFtZSwgZXJyb3IpICYmIHNob3VsZFJlbmRlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgZnVuY3Rpb24gZ2V0VmFsdWVzKHBheWxvYWQpIHtcclxuICAgICAgICBpZiAoaXNTdHJpbmcocGF5bG9hZCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGdldEZpZWxkVmFsdWUoZmllbGRzUmVmLCBwYXlsb2FkLCB1bm1vdW50RmllbGRzU3RhdGVSZWYpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNBcnJheShwYXlsb2FkKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZC5yZWR1Y2UoKHByZXZpb3VzLCBuYW1lKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2aW91cyksIHsgW25hbWVdOiBnZXRGaWVsZFZhbHVlKGZpZWxkc1JlZiwgbmFtZSwgdW5tb3VudEZpZWxkc1N0YXRlUmVmKSB9KSksIHt9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGdldEZpZWxkc1ZhbHVlcyhmaWVsZHNSZWYsIHVubW91bnRGaWVsZHNTdGF0ZVJlZik7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2YWxpZGF0ZVJlc29sdmVyID0gdXNlQ2FsbGJhY2soYXN5bmMgKHZhbHVlcyA9IHt9KSA9PiB7XHJcbiAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IHJlc29sdmVyUmVmLmN1cnJlbnQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCksIGdldFZhbHVlcygpKSwgdmFsdWVzKSwgY29udGV4dFJlZi5jdXJyZW50LCBpc1ZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSk7XHJcbiAgICAgICAgY29uc3QgcHJldmlvdXNGb3JtSXNWYWxpZCA9IGlzVmFsaWRSZWYuY3VycmVudDtcclxuICAgICAgICBpc1ZhbGlkUmVmLmN1cnJlbnQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XHJcbiAgICAgICAgaWYgKHByZXZpb3VzRm9ybUlzVmFsaWQgIT09IGlzVmFsaWRSZWYuY3VycmVudCkge1xyXG4gICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgIH1cclxuICAgIH0sIFtpc1ZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYV0pO1xyXG4gICAgY29uc3QgcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyID0gdXNlQ2FsbGJhY2soKGZpZWxkLCBmb3JjZURlbGV0ZSkgPT4gZmluZFJlbW92ZWRGaWVsZEFuZFJlbW92ZUxpc3RlbmVyKGZpZWxkc1JlZiwgaGFuZGxlQ2hhbmdlUmVmLmN1cnJlbnQsIGZpZWxkLCB1bm1vdW50RmllbGRzU3RhdGVSZWYsIHNob3VsZFVucmVnaXN0ZXIsIGZvcmNlRGVsZXRlKSwgW3Nob3VsZFVucmVnaXN0ZXJdKTtcclxuICAgIGNvbnN0IHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lckFuZFJlZiA9IHVzZUNhbGxiYWNrKChmaWVsZCwgZm9yY2VEZWxldGUpID0+IHtcclxuICAgICAgICBpZiAoZmllbGQgJiZcclxuICAgICAgICAgICAgKCFpc05hbWVJbkZpZWxkQXJyYXkoZmllbGRBcnJheU5hbWVzUmVmLmN1cnJlbnQsIGZpZWxkLnJlZi5uYW1lKSB8fFxyXG4gICAgICAgICAgICAgICAgZm9yY2VEZWxldGUpKSB7XHJcbiAgICAgICAgICAgIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lcihmaWVsZCwgZm9yY2VEZWxldGUpO1xyXG4gICAgICAgICAgICBpZiAoc2hvdWxkVW5yZWdpc3Rlcikge1xyXG4gICAgICAgICAgICAgICAgW1xyXG4gICAgICAgICAgICAgICAgICAgIGVycm9yc1JlZixcclxuICAgICAgICAgICAgICAgICAgICB0b3VjaGVkRmllbGRzUmVmLFxyXG4gICAgICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzUmVmLFxyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXNBdFJlbmRlclJlZixcclxuICAgICAgICAgICAgICAgIF0uZm9yRWFjaCgoZGF0YSkgPT4gdW5zZXQoZGF0YS5jdXJyZW50LCBmaWVsZC5yZWYubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgW2ZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLCB2YWxpZEZpZWxkc1JlZl0uZm9yRWFjaCgoZGF0YSkgPT4gZGF0YS5jdXJyZW50LmRlbGV0ZShmaWVsZC5yZWYubmFtZSkpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQgfHxcclxuICAgICAgICAgICAgICAgICAgICByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNEaXJ0eSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlzRGlydHlSZWYuY3VycmVudCA9ICFpc0VtcHR5T2JqZWN0KGRpcnR5RmllbGRzUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc29sdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVSZXNvbHZlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFt2YWxpZGF0ZVJlc29sdmVyLCByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXJdKTtcclxuICAgIGZ1bmN0aW9uIGNsZWFyRXJyb3JzKG5hbWUpIHtcclxuICAgICAgICBpZiAobmFtZSkge1xyXG4gICAgICAgICAgICAoaXNBcnJheShuYW1lKSA/IG5hbWUgOiBbbmFtZV0pLmZvckVhY2goKGlucHV0TmFtZSkgPT4gdW5zZXQoZXJyb3JzUmVmLmN1cnJlbnQsIGlucHV0TmFtZSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZXJyb3JzUmVmLmN1cnJlbnQgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHNldEVycm9yKG5hbWUsIGVycm9yKSB7XHJcbiAgICAgICAgaXNWYWxpZFJlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgc2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVycm9yKSwgeyByZWY6IChmaWVsZHNSZWYuY3VycmVudFtuYW1lXSB8fCB7fSkucmVmIH0pKTtcclxuICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgfVxyXG4gICAgY29uc3Qgd2F0Y2hJbnRlcm5hbCA9IHVzZUNhbGxiYWNrKChmaWVsZE5hbWVzLCBkZWZhdWx0VmFsdWUsIHdhdGNoSWQpID0+IHtcclxuICAgICAgICBjb25zdCB3YXRjaEZpZWxkcyA9IHdhdGNoSWRcclxuICAgICAgICAgICAgPyB3YXRjaEZpZWxkc0hvb2tSZWYuY3VycmVudFt3YXRjaElkXVxyXG4gICAgICAgICAgICA6IHdhdGNoRmllbGRzUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgY29uc3QgY29tYmluZWREZWZhdWx0VmFsdWVzID0gaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKVxyXG4gICAgICAgICAgICA/IGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudFxyXG4gICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEZpZWxkc1ZhbHVlcyhmaWVsZHNSZWYsIHVubW91bnRGaWVsZHNTdGF0ZVJlZiwgZmllbGROYW1lcyk7XHJcbiAgICAgICAgaWYgKGlzU3RyaW5nKGZpZWxkTmFtZXMpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhc3NpZ25XYXRjaEZpZWxkcyhmaWVsZFZhbHVlcywgZmllbGROYW1lcywgd2F0Y2hGaWVsZHMsIGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICAgICAgICAgID8gZ2V0KGNvbWJpbmVkRGVmYXVsdFZhbHVlcywgZmllbGROYW1lcylcclxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlLCB0cnVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZmllbGROYW1lcykpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZpZWxkTmFtZXMucmVkdWNlKChwcmV2aW91cywgbmFtZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldmlvdXMpLCB7IFtuYW1lXTogYXNzaWduV2F0Y2hGaWVsZHMoZmllbGRWYWx1ZXMsIG5hbWUsIHdhdGNoRmllbGRzLCBjb21iaW5lZERlZmF1bHRWYWx1ZXMpIH0pKSwge30pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQod2F0Y2hJZCkpIHtcclxuICAgICAgICAgICAgaXNXYXRjaEFsbFJlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVRvTmVzdE9iamVjdCgoIWlzRW1wdHlPYmplY3QoZmllbGRWYWx1ZXMpICYmIGZpZWxkVmFsdWVzKSB8fFxyXG4gICAgICAgICAgICBjb21iaW5lZERlZmF1bHRWYWx1ZXMpO1xyXG4gICAgfSwgW10pO1xyXG4gICAgZnVuY3Rpb24gd2F0Y2goZmllbGROYW1lcywgZGVmYXVsdFZhbHVlKSB7XHJcbiAgICAgICAgcmV0dXJuIHdhdGNoSW50ZXJuYWwoZmllbGROYW1lcywgZGVmYXVsdFZhbHVlKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHVucmVnaXN0ZXIobmFtZSkge1xyXG4gICAgICAgIChpc0FycmF5KG5hbWUpID8gbmFtZSA6IFtuYW1lXSkuZm9yRWFjaCgoZmllbGROYW1lKSA9PiByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXJBbmRSZWYoZmllbGRzUmVmLmN1cnJlbnRbZmllbGROYW1lXSwgdHJ1ZSkpO1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJGaWVsZFJlZihyZWYsIHZhbGlkYXRlT3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICAgICAgaWYgKCFyZWYubmFtZSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbnNvbGUud2Fybign8J+TiyBGaWVsZCBpcyBtaXNzaW5nIGBuYW1lYCBhdHRyaWJ1dGU6JywgcmVmKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZmllbGRBcnJheU5hbWVzUmVmLmN1cnJlbnQuaGFzKHJlZi5uYW1lLnNwbGl0KC9cXFtcXGQrXFxdJC8pWzBdKSAmJlxyXG4gICAgICAgICAgICAgICAgIVJlZ0V4cChgXiR7cmVmLm5hbWUuc3BsaXQoL1xcW1xcZCtcXF0kLylbMF19W1xcXFxkK11cXC5cXFxcdytgXHJcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcWy9nLCAnXFxcXFsnKVxyXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXF0vZywgJ1xcXFxdJykpLnRlc3QocmVmLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCfwn5OLIGBuYW1lYCBwcm9wIHNob3VsZCBiZSBpbiBvYmplY3Qgc2hhcGU6IG5hbWU9XCJ0ZXN0W2luZGV4XS5uYW1lXCIuIGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9hcGkjdXNlRmllbGRBcnJheScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHsgbmFtZSwgdHlwZSwgdmFsdWUgfSA9IHJlZjtcclxuICAgICAgICBjb25zdCBmaWVsZFJlZkFuZFZhbGlkYXRpb25PcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHJlZiB9LCB2YWxpZGF0ZU9wdGlvbnMpO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkcyA9IGZpZWxkc1JlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IGlzUmFkaW9PckNoZWNrYm94ID0gaXNSYWRpb09yQ2hlY2tib3hGdW5jdGlvbihyZWYpO1xyXG4gICAgICAgIGxldCBmaWVsZCA9IGZpZWxkc1tuYW1lXTtcclxuICAgICAgICBsZXQgaXNFbXB0eURlZmF1bHRWYWx1ZSA9IHRydWU7XHJcbiAgICAgICAgbGV0IGlzRmllbGRBcnJheTtcclxuICAgICAgICBsZXQgZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIGlmIChmaWVsZCAmJlxyXG4gICAgICAgICAgICAoaXNSYWRpb09yQ2hlY2tib3hcclxuICAgICAgICAgICAgICAgID8gaXNBcnJheShmaWVsZC5vcHRpb25zKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZShmaWVsZC5vcHRpb25zKS5maW5kKChvcHRpb24pID0+IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlID09PSBvcHRpb24ucmVmLnZhbHVlICYmIG9wdGlvbi5yZWYgPT09IHJlZjtcclxuICAgICAgICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgICAgOiByZWYgPT09IGZpZWxkLnJlZikpIHtcclxuICAgICAgICAgICAgZmllbGRzW25hbWVdID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmaWVsZCksIHZhbGlkYXRlT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgY29uc3QgbXV0YXRpb25XYXRjaGVyID0gb25Eb21SZW1vdmUocmVmLCAoKSA9PiByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXJBbmRSZWYoZmllbGQpKTtcclxuICAgICAgICAgICAgZmllbGQgPSBpc1JhZGlvT3JDaGVja2JveFxyXG4gICAgICAgICAgICAgICAgPyBPYmplY3QuYXNzaWduKHsgb3B0aW9uczogW1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi51bmlxdWUoKGZpZWxkICYmIGZpZWxkLm9wdGlvbnMpIHx8IFtdKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbXV0YXRpb25XYXRjaGVyLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIF0sIHJlZjogeyB0eXBlLCBuYW1lIH0gfSwgdmFsaWRhdGVPcHRpb25zKSA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmllbGRSZWZBbmRWYWxpZGF0aW9uT3B0aW9ucyksIHsgbXV0YXRpb25XYXRjaGVyIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZmllbGQgPSBmaWVsZFJlZkFuZFZhbGlkYXRpb25PcHRpb25zO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaWVsZHNbbmFtZV0gPSBmaWVsZDtcclxuICAgICAgICBjb25zdCBpc0VtcHR5VW5tb3VudEZpZWxkcyA9IGlzVW5kZWZpbmVkKGdldCh1bm1vdW50RmllbGRzU3RhdGVSZWYuY3VycmVudCwgbmFtZSkpO1xyXG4gICAgICAgIGlmICghaXNFbXB0eU9iamVjdChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQpIHx8ICFpc0VtcHR5VW5tb3VudEZpZWxkcykge1xyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWUgPSBnZXQoaXNFbXB0eVVubW91bnRGaWVsZHNcclxuICAgICAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50XHJcbiAgICAgICAgICAgICAgICA6IHVubW91bnRGaWVsZHNTdGF0ZVJlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICAgICAgaXNFbXB0eURlZmF1bHRWYWx1ZSA9IGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSk7XHJcbiAgICAgICAgICAgIGlzRmllbGRBcnJheSA9IGlzTmFtZUluRmllbGRBcnJheShmaWVsZEFycmF5TmFtZXNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICAgICAgICAgIGlmICghaXNFbXB0eURlZmF1bHRWYWx1ZSAmJiAhaXNGaWVsZEFycmF5KSB7XHJcbiAgICAgICAgICAgICAgICBzZXRGaWVsZFZhbHVlKGZpZWxkLCBkZWZhdWx0VmFsdWUpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZXNvbHZlciAmJiAhaXNGaWVsZEFycmF5ICYmIHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlUmVzb2x2ZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoIWlzRW1wdHlPYmplY3QodmFsaWRhdGVPcHRpb25zKSkge1xyXG4gICAgICAgICAgICBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZi5jdXJyZW50LmFkZChuYW1lKTtcclxuICAgICAgICAgICAgaWYgKCFpc09uU3VibWl0ICYmIHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgICAgICB2YWxpZGF0ZUZpZWxkKGZpZWxkc1JlZiwgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIGZpZWxkLCB1bm1vdW50RmllbGRzU3RhdGVSZWYpLnRoZW4oKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNGb3JtSXNWYWxpZCA9IGlzVmFsaWRSZWYuY3VycmVudDtcclxuICAgICAgICAgICAgICAgICAgICBpc0VtcHR5T2JqZWN0KGVycm9yKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbGlkRmllbGRzUmVmLmN1cnJlbnQuYWRkKG5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogKGlzVmFsaWRSZWYuY3VycmVudCA9IGZhbHNlKTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJldmlvdXNGb3JtSXNWYWxpZCAhPT0gaXNWYWxpZFJlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkZWZhdWx0VmFsdWVzQXRSZW5kZXJSZWYuY3VycmVudFtuYW1lXSAmJlxyXG4gICAgICAgICAgICAhKGlzRmllbGRBcnJheSAmJiBpc0VtcHR5RGVmYXVsdFZhbHVlKSkge1xyXG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gZ2V0RmllbGRWYWx1ZShmaWVsZHNSZWYsIG5hbWUsIHVubW91bnRGaWVsZHNTdGF0ZVJlZik7XHJcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZXNBdFJlbmRlclJlZi5jdXJyZW50W25hbWVdID0gaXNFbXB0eURlZmF1bHRWYWx1ZVxyXG4gICAgICAgICAgICAgICAgPyBpc09iamVjdChmaWVsZFZhbHVlKVxyXG4gICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih7fSwgZmllbGRWYWx1ZSkgOiBmaWVsZFZhbHVlXHJcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGUpIHtcclxuICAgICAgICAgICAgYXR0YWNoRXZlbnRMaXN0ZW5lcnMoaXNSYWRpb09yQ2hlY2tib3ggJiYgZmllbGQub3B0aW9uc1xyXG4gICAgICAgICAgICAgICAgPyBmaWVsZC5vcHRpb25zW2ZpZWxkLm9wdGlvbnMubGVuZ3RoIC0gMV1cclxuICAgICAgICAgICAgICAgIDogZmllbGQsIGlzUmFkaW9PckNoZWNrYm94IHx8IGlzU2VsZWN0SW5wdXQocmVmKSwgaGFuZGxlQ2hhbmdlUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyKHJlZk9yVmFsaWRhdGlvbk9wdGlvbnMsIHJ1bGVzKSB7XHJcbiAgICAgICAgaWYgKCFpc1dpbmRvd1VuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcocmVmT3JWYWxpZGF0aW9uT3B0aW9ucykpIHtcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyRmllbGRSZWYoeyBuYW1lOiByZWZPclZhbGlkYXRpb25PcHRpb25zIH0sIHJ1bGVzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdChyZWZPclZhbGlkYXRpb25PcHRpb25zKSAmJlxyXG4gICAgICAgICAgICAgICAgJ25hbWUnIGluIHJlZk9yVmFsaWRhdGlvbk9wdGlvbnMpIHtcclxuICAgICAgICAgICAgICAgIHJlZ2lzdGVyRmllbGRSZWYocmVmT3JWYWxpZGF0aW9uT3B0aW9ucywgcnVsZXMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIChyZWYpID0+IHJlZiAmJiByZWdpc3RlckZpZWxkUmVmKHJlZiwgcmVmT3JWYWxpZGF0aW9uT3B0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBoYW5kbGVTdWJtaXQgPSB1c2VDYWxsYmFjaygoY2FsbGJhY2spID0+IGFzeW5jIChlKSA9PiB7XHJcbiAgICAgICAgaWYgKGUgJiYgZS5wcmV2ZW50RGVmYXVsdCkge1xyXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGUucGVyc2lzdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgZmllbGRFcnJvcnMgPSB7fTtcclxuICAgICAgICBsZXQgZmllbGRWYWx1ZXMgPSBnZXRGaWVsZHNWYWx1ZXMoZmllbGRzUmVmLCB1bm1vdW50RmllbGRzU3RhdGVSZWYpO1xyXG4gICAgICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNTdWJtaXR0aW5nKSB7XHJcbiAgICAgICAgICAgIGlzU3VibWl0dGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcclxuICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHJlc29sdmVyUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3JzLCB2YWx1ZXMgfSA9IGF3YWl0IHJlc29sdmVyUmVmLmN1cnJlbnQoZmllbGRWYWx1ZXMsIGNvbnRleHRSZWYuY3VycmVudCwgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpO1xyXG4gICAgICAgICAgICAgICAgZXJyb3JzUmVmLmN1cnJlbnQgPSBlcnJvcnM7XHJcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9ycyA9IGVycm9ycztcclxuICAgICAgICAgICAgICAgIGZpZWxkVmFsdWVzID0gdmFsdWVzO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiBPYmplY3QudmFsdWVzKGZpZWxkc1JlZi5jdXJyZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlZjogeyBuYW1lIH0sIH0gPSBmaWVsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRFcnJvciA9IGF3YWl0IHZhbGlkYXRlRmllbGQoZmllbGRzUmVmLCBpc1ZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZmllbGQsIHVubW91bnRGaWVsZHNTdGF0ZVJlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZEVycm9yW25hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQoZmllbGRFcnJvcnMsIG5hbWUsIGZpZWxkRXJyb3JbbmFtZV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRGaWVsZHNSZWYuY3VycmVudC5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudC5oYXMobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuc2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkRmllbGRzUmVmLmN1cnJlbnQuYWRkKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KGZpZWxkRXJyb3JzKSAmJlxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZXJyb3JzUmVmLmN1cnJlbnQpLmV2ZXJ5KChuYW1lKSA9PiBPYmplY3Qua2V5cyhmaWVsZHNSZWYuY3VycmVudCkuaW5jbHVkZXMobmFtZSkpKSB7XHJcbiAgICAgICAgICAgICAgICBlcnJvcnNSZWYuY3VycmVudCA9IHt9O1xyXG4gICAgICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKGZpZWxkVmFsdWVzLCBlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGVycm9yc1JlZi5jdXJyZW50ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlcnJvcnNSZWYuY3VycmVudCksIGZpZWxkRXJyb3JzKTtcclxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRGb2N1c0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkVycm9yRmllbGQoZmllbGRzUmVmLmN1cnJlbnQsIGZpZWxkRXJyb3JzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHtcclxuICAgICAgICAgICAgaXNTdWJtaXR0ZWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIGlzU3VibWl0dGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHN1Ym1pdENvdW50UmVmLmN1cnJlbnQgPSBzdWJtaXRDb3VudFJlZi5jdXJyZW50ICsgMTtcclxuICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICB9LCBbc2hvdWxkRm9jdXNFcnJvciwgaXNWYWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWFdKTtcclxuICAgIGNvbnN0IHJlc2V0UmVmcyA9ICh7IGVycm9ycywgaXNEaXJ0eSwgaXNTdWJtaXR0ZWQsIHRvdWNoZWQsIGlzVmFsaWQsIHN1Ym1pdENvdW50LCBkaXJ0eUZpZWxkcywgfSkgPT4ge1xyXG4gICAgICAgIGlmICghZXJyb3JzKSB7XHJcbiAgICAgICAgICAgIGVycm9yc1JlZi5jdXJyZW50ID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdG91Y2hlZCkge1xyXG4gICAgICAgICAgICB0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnQgPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkRmllbGRzUmVmLmN1cnJlbnQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQgPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgICAgIGlzVmFsaWRSZWYuY3VycmVudCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNEaXJ0eSkge1xyXG4gICAgICAgICAgICBpc0RpcnR5UmVmLmN1cnJlbnQgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFkaXJ0eUZpZWxkcykge1xyXG4gICAgICAgICAgICBkaXJ0eUZpZWxkc1JlZi5jdXJyZW50ID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghaXNTdWJtaXR0ZWQpIHtcclxuICAgICAgICAgICAgaXNTdWJtaXR0ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXN1Ym1pdENvdW50KSB7XHJcbiAgICAgICAgICAgIHN1Ym1pdENvdW50UmVmLmN1cnJlbnQgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWZhdWx0VmFsdWVzQXRSZW5kZXJSZWYuY3VycmVudCA9IHt9O1xyXG4gICAgICAgIGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzLmN1cnJlbnQgPSB7fTtcclxuICAgICAgICB3YXRjaEZpZWxkc1JlZi5jdXJyZW50ID0gbmV3IFNldCgpO1xyXG4gICAgICAgIGlzV2F0Y2hBbGxSZWYuY3VycmVudCA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc2V0ID0gKHZhbHVlcywgb21pdFJlc2V0U3RhdGUgPSB7fSkgPT4ge1xyXG4gICAgICAgIGlmIChpc1dlYikge1xyXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIE9iamVjdC52YWx1ZXMoZmllbGRzUmVmLmN1cnJlbnQpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHJlZiwgb3B0aW9ucyB9ID0gZmllbGQ7XHJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRSZWYgPSBpc1JhZGlvT3JDaGVja2JveEZ1bmN0aW9uKHJlZikgJiYgaXNBcnJheShvcHRpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnNbMF0ucmVmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0hUTUxFbGVtZW50KGlucHV0UmVmKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRSZWYuY2xvc2VzdCgnZm9ybScpLnJlc2V0KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmaWVsZHNSZWYuY3VycmVudCA9IHt9O1xyXG4gICAgICAgIGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCA9IHZhbHVlcyB8fCBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQpO1xyXG4gICAgICAgIGlmICh2YWx1ZXMpIHtcclxuICAgICAgICAgICAgcmVuZGVyV2F0Y2hlZElucHV0cygnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHVubW91bnRGaWVsZHNTdGF0ZVJlZi5jdXJyZW50ID0gc2hvdWxkVW5yZWdpc3RlciA/IHt9IDogdmFsdWVzIHx8IHt9O1xyXG4gICAgICAgIE9iamVjdC52YWx1ZXMocmVzZXRGaWVsZEFycmF5RnVuY3Rpb25SZWYuY3VycmVudCkuZm9yRWFjaCgocmVzZXRGaWVsZEFycmF5KSA9PiBpc0Z1bmN0aW9uKHJlc2V0RmllbGRBcnJheSkgJiYgcmVzZXRGaWVsZEFycmF5KCkpO1xyXG4gICAgICAgIHJlc2V0UmVmcyhvbWl0UmVzZXRTdGF0ZSk7XHJcbiAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgIH07XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGlzVW5Nb3VudC5jdXJyZW50ID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgaXNVbk1vdW50LmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICBmaWVsZHNSZWYuY3VycmVudCAmJlxyXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhmaWVsZHNSZWYuY3VycmVudCkuZm9yRWFjaCgoZmllbGQpID0+IHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lckFuZFJlZihmaWVsZCwgdHJ1ZSkpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbcmVtb3ZlRmllbGRFdmVudExpc3RlbmVyQW5kUmVmXSk7XHJcbiAgICBpZiAoIXJlc29sdmVyKSB7XHJcbiAgICAgICAgaXNWYWxpZFJlZi5jdXJyZW50ID1cclxuICAgICAgICAgICAgdmFsaWRGaWVsZHNSZWYuY3VycmVudC5zaXplID49IGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQuc2l6ZSAmJlxyXG4gICAgICAgICAgICAgICAgaXNFbXB0eU9iamVjdChlcnJvcnNSZWYuY3VycmVudCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBmb3JtU3RhdGUgPSB7XHJcbiAgICAgICAgZGlydHlGaWVsZHM6IGRpcnR5RmllbGRzUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGlzU3VibWl0dGVkUmVmLmN1cnJlbnQsXHJcbiAgICAgICAgc3VibWl0Q291bnQ6IHN1Ym1pdENvdW50UmVmLmN1cnJlbnQsXHJcbiAgICAgICAgdG91Y2hlZDogdG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50LFxyXG4gICAgICAgIGlzRGlydHk6IGlzRGlydHlSZWYuY3VycmVudCxcclxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGlzU3VibWl0dGluZ1JlZi5jdXJyZW50LFxyXG4gICAgICAgIGlzVmFsaWQ6IGlzT25TdWJtaXRcclxuICAgICAgICAgICAgPyBpc1N1Ym1pdHRlZFJlZi5jdXJyZW50ICYmIGlzRW1wdHlPYmplY3QoZXJyb3JzUmVmLmN1cnJlbnQpXHJcbiAgICAgICAgICAgIDogaXNWYWxpZFJlZi5jdXJyZW50LFxyXG4gICAgfTtcclxuICAgIGNvbnN0IGNvbW1vblByb3BzID0ge1xyXG4gICAgICAgIHRyaWdnZXIsXHJcbiAgICAgICAgc2V0VmFsdWU6IHVzZUNhbGxiYWNrKHNldFZhbHVlLCBbXHJcbiAgICAgICAgICAgIHJlUmVuZGVyLFxyXG4gICAgICAgICAgICBzZXRJbnRlcm5hbFZhbHVlLFxyXG4gICAgICAgICAgICB0cmlnZ2VyLFxyXG4gICAgICAgIF0pLFxyXG4gICAgICAgIGdldFZhbHVlczogdXNlQ2FsbGJhY2soZ2V0VmFsdWVzLCBbXSksXHJcbiAgICAgICAgcmVnaXN0ZXI6IHVzZUNhbGxiYWNrKHJlZ2lzdGVyLCBbZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50XSksXHJcbiAgICAgICAgdW5yZWdpc3RlcjogdXNlQ2FsbGJhY2sodW5yZWdpc3RlciwgW10pLFxyXG4gICAgICAgIGZvcm1TdGF0ZTogaXNQcm94eUVuYWJsZWRcclxuICAgICAgICAgICAgPyBuZXcgUHJveHkoZm9ybVN0YXRlLCB7XHJcbiAgICAgICAgICAgICAgICBnZXQ6IChvYmosIHByb3ApID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9wID09PSAnaXNWYWxpZCcgJiZcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXNPblN1Ym1pdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ/Cfk4sgYGZvcm1TdGF0ZS5pc1ZhbGlkYCBpcyBhcHBsaWNhYmxlIHdpdGggYG9uQ2hhbmdlYCBvciBgb25CbHVyYCBtb2RlLiBodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vYXBpI2Zvcm1TdGF0ZScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAocHJvcCBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50W3Byb3BdID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ialtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogZm9ybVN0YXRlLFxyXG4gICAgfTtcclxuICAgIGNvbnN0IGNvbnRyb2wgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIsXHJcbiAgICAgICAgcmVuZGVyV2F0Y2hlZElucHV0cyxcclxuICAgICAgICB3YXRjaEludGVybmFsLFxyXG4gICAgICAgIHJlUmVuZGVyLCBtb2RlOiBtb2RlUmVmLmN1cnJlbnQsIHJlVmFsaWRhdGVNb2RlOiB7XHJcbiAgICAgICAgICAgIGlzUmVWYWxpZGF0ZU9uQmx1cixcclxuICAgICAgICAgICAgaXNSZVZhbGlkYXRlT25DaGFuZ2UsXHJcbiAgICAgICAgfSwgZXJyb3JzUmVmLFxyXG4gICAgICAgIHRvdWNoZWRGaWVsZHNSZWYsXHJcbiAgICAgICAgZmllbGRzUmVmLFxyXG4gICAgICAgIGlzV2F0Y2hBbGxSZWYsXHJcbiAgICAgICAgd2F0Y2hGaWVsZHNSZWYsXHJcbiAgICAgICAgcmVzZXRGaWVsZEFycmF5RnVuY3Rpb25SZWYsXHJcbiAgICAgICAgd2F0Y2hGaWVsZHNIb29rUmVmLFxyXG4gICAgICAgIHdhdGNoRmllbGRzSG9va1JlbmRlclJlZixcclxuICAgICAgICBmaWVsZEFycmF5RGVmYXVsdFZhbHVlcyxcclxuICAgICAgICB2YWxpZEZpZWxkc1JlZixcclxuICAgICAgICBkaXJ0eUZpZWxkc1JlZixcclxuICAgICAgICBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZixcclxuICAgICAgICBmaWVsZEFycmF5TmFtZXNSZWYsXHJcbiAgICAgICAgaXNEaXJ0eVJlZixcclxuICAgICAgICBpc1N1Ym1pdHRlZFJlZixcclxuICAgICAgICByZWFkRm9ybVN0YXRlUmVmLFxyXG4gICAgICAgIGRlZmF1bHRWYWx1ZXNSZWYsXHJcbiAgICAgICAgdW5tb3VudEZpZWxkc1N0YXRlUmVmIH0sIChyZXNvbHZlciA/IHsgdmFsaWRhdGVTY2hlbWFJc1ZhbGlkOiB2YWxpZGF0ZVJlc29sdmVyIH0gOiB7fSkpLCBjb21tb25Qcm9wcyk7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IHdhdGNoLFxyXG4gICAgICAgIGNvbnRyb2wsXHJcbiAgICAgICAgaGFuZGxlU3VibWl0LCByZXNldDogdXNlQ2FsbGJhY2socmVzZXQsIFtdKSwgY2xlYXJFcnJvcnM6IHVzZUNhbGxiYWNrKGNsZWFyRXJyb3JzLCBbXSksIHNldEVycm9yOiB1c2VDYWxsYmFjayhzZXRFcnJvciwgW10pLCBlcnJvcnM6IGVycm9yc1JlZi5jdXJyZW50IH0sIGNvbW1vblByb3BzKTtcclxufVxuXG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XG5cbmNvbnN0IEZvcm1Db250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcclxuRm9ybUNvbnRleHQuZGlzcGxheU5hbWUgPSAnUkhGQ29udGV4dCc7XHJcbmNvbnN0IHVzZUZvcm1Db250ZXh0ID0gKCkgPT4gdXNlQ29udGV4dChGb3JtQ29udGV4dCk7XHJcbmNvbnN0IEZvcm1Qcm92aWRlciA9IChfYSkgPT4ge1xyXG4gICAgdmFyIHsgY2hpbGRyZW4gfSA9IF9hLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIl0pO1xyXG4gICAgcmV0dXJuIChjcmVhdGVFbGVtZW50KEZvcm1Db250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBPYmplY3QuYXNzaWduKHt9LCBwcm9wcykgfSwgY2hpbGRyZW4pKTtcclxufTtcblxudmFyIGdlbmVyYXRlSWQgPSAoKSA9PiB7XHJcbiAgICBjb25zdCBkID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSBVTkRFRklORUQgPyBEYXRlLm5vdygpIDogcGVyZm9ybWFuY2Uubm93KCkgKiAxMDAwO1xyXG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgZnVuY3Rpb24gKGMpIHtcclxuICAgICAgICBjb25zdCByID0gKE1hdGgucmFuZG9tKCkgKiAxNiArIGQpICUgMTYgfCAwO1xyXG4gICAgICAgIHJldHVybiAoYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4KS50b1N0cmluZygxNik7XHJcbiAgICB9KTtcclxufTtcblxuY29uc3QgcmVtb3ZlQXQgPSAoZGF0YSwgaW5kZXgpID0+IFtcclxuICAgIC4uLmRhdGEuc2xpY2UoMCwgaW5kZXgpLFxyXG4gICAgLi4uZGF0YS5zbGljZShpbmRleCArIDEpLFxyXG5dO1xyXG5mdW5jdGlvbiByZW1vdmVBdEluZGV4ZXMoZGF0YSwgaW5kZXgpIHtcclxuICAgIGxldCBrID0gLTE7XHJcbiAgICB3aGlsZSAoKytrIDwgZGF0YS5sZW5ndGgpIHtcclxuICAgICAgICBpZiAoaW5kZXguaW5kZXhPZihrKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBkYXRhW2tdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB1bmlxdWUoZGF0YSk7XHJcbn1cclxudmFyIHJlbW92ZUFycmF5QXQgPSAoZGF0YSwgaW5kZXgpID0+IGlzVW5kZWZpbmVkKGluZGV4KVxyXG4gICAgPyBbXVxyXG4gICAgOiBpc0FycmF5KGluZGV4KVxyXG4gICAgICAgID8gcmVtb3ZlQXRJbmRleGVzKGRhdGEsIGluZGV4KVxyXG4gICAgICAgIDogcmVtb3ZlQXQoZGF0YSwgaW5kZXgpO1xuXG52YXIgbW92ZUFycmF5QXQgPSAoZGF0YSwgZnJvbSwgdG8pID0+IHtcclxuICAgIGlmIChpc0FycmF5KGRhdGEpKSB7XHJcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGRhdGFbdG9dKSkge1xyXG4gICAgICAgICAgICBkYXRhW3RvXSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YS5zcGxpY2UodG8sIDAsIGRhdGEuc3BsaWNlKGZyb20sIDEpWzBdKTtcclxuICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxufTtcblxudmFyIHN3YXBBcnJheUF0ID0gKGRhdGEsIGluZGV4QSwgaW5kZXhCKSA9PiB7XHJcbiAgICBjb25zdCB0ZW1wID0gW2RhdGFbaW5kZXhCXSwgZGF0YVtpbmRleEFdXTtcclxuICAgIGRhdGFbaW5kZXhBXSA9IHRlbXBbMF07XHJcbiAgICBkYXRhW2luZGV4Ql0gPSB0ZW1wWzFdO1xyXG59O1xuXG5mdW5jdGlvbiBwcmVwZW5kKGRhdGEsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gWy4uLihpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlIHx8IHVuZGVmaW5lZF0pLCAuLi5kYXRhXTtcclxufVxuXG5mdW5jdGlvbiBpbnNlcnQoZGF0YSwgaW5kZXgsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gW1xyXG4gICAgICAgIC4uLmRhdGEuc2xpY2UoMCwgaW5kZXgpLFxyXG4gICAgICAgIC4uLihpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlIHx8IHVuZGVmaW5lZF0pLFxyXG4gICAgICAgIC4uLmRhdGEuc2xpY2UoaW5kZXgpLFxyXG4gICAgXTtcclxufVxuXG52YXIgZmlsbEVtcHR5QXJyYXkgPSAodmFsdWUpID0+IGlzQXJyYXkodmFsdWUpID8gQXJyYXkodmFsdWUubGVuZ3RoKS5maWxsKHVuZGVmaW5lZCkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIG1hcFZhbHVlVG9Cb29sZWFuKHZhbHVlKSB7XHJcbiAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgY29uc3Qgb2JqZWN0ID0ge307XHJcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsdWUpIHtcclxuICAgICAgICAgICAgb2JqZWN0W2tleV0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW29iamVjdF07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gW3RydWVdO1xyXG59XHJcbmNvbnN0IGZpbHRlckJvb2xlYW5BcnJheSA9ICh2YWx1ZSkgPT4gaXNBcnJheSh2YWx1ZSlcclxuICAgID8gdmFsdWUubWFwKG1hcFZhbHVlVG9Cb29sZWFuKS5mbGF0KClcclxuICAgIDogbWFwVmFsdWVUb0Jvb2xlYW4odmFsdWUpO1xuXG5jb25zdCBhcHBlbmRJZCA9ICh2YWx1ZSwga2V5TmFtZSkgPT4gKE9iamVjdC5hc3NpZ24oeyBba2V5TmFtZV06IGdlbmVyYXRlSWQoKSB9LCAoaXNPYmplY3QodmFsdWUpID8gdmFsdWUgOiB7IHZhbHVlIH0pKSk7XHJcbmNvbnN0IG1hcElkcyA9IChkYXRhLCBrZXlOYW1lKSA9PiAoaXNBcnJheShkYXRhKSA/IGRhdGEgOiBbXSkubWFwKCh2YWx1ZSkgPT4gYXBwZW5kSWQodmFsdWUsIGtleU5hbWUpKTtcclxuY29uc3QgdXNlRmllbGRBcnJheSA9ICh7IGNvbnRyb2wsIG5hbWUsIGtleU5hbWUgPSAnaWQnLCB9KSA9PiB7XHJcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgaWYgKCFjb250cm9sICYmICFtZXRob2RzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcign8J+TiyB1c2VGaWVsZEFycmF5IGlzIG1pc3NpbmcgYGNvbnRyb2xgIHByb3AuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ/Cfk4sgdXNlRmllbGRBcnJheSBpcyBtaXNzaW5nIGBuYW1lYCBhdHRyaWJ1dGUuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3QgZm9jdXNJbmRleFJlZiA9IHVzZVJlZigtMSk7XHJcbiAgICBjb25zdCB7IGlzV2F0Y2hBbGxSZWYsIHJlc2V0RmllbGRBcnJheUZ1bmN0aW9uUmVmLCBmaWVsZEFycmF5TmFtZXNSZWYsIHJlUmVuZGVyLCBmaWVsZHNSZWYsIGRlZmF1bHRWYWx1ZXNSZWYsIHJlbW92ZUZpZWxkRXZlbnRMaXN0ZW5lciwgZXJyb3JzUmVmLCBkaXJ0eUZpZWxkc1JlZiwgaXNEaXJ0eVJlZiwgdG91Y2hlZEZpZWxkc1JlZiwgcmVhZEZvcm1TdGF0ZVJlZiwgd2F0Y2hGaWVsZHNSZWYsIHZhbGlkRmllbGRzUmVmLCBmaWVsZHNXaXRoVmFsaWRhdGlvblJlZiwgZmllbGRBcnJheURlZmF1bHRWYWx1ZXMsIHZhbGlkYXRlU2NoZW1hSXNWYWxpZCwgcmVuZGVyV2F0Y2hlZElucHV0cywgZ2V0VmFsdWVzLCB9ID0gY29udHJvbCB8fCBtZXRob2RzLmNvbnRyb2w7XHJcbiAgICBsZXQgc2hvdWxkUmVuZGVyO1xyXG4gICAgY29uc3QgZ2V0RGVmYXVsdFZhbHVlcyA9ICgpID0+IFtcclxuICAgICAgICAuLi4oZ2V0KGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzLmN1cnJlbnQsIG5hbWUpIHx8XHJcbiAgICAgICAgICAgIGdldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUpIHx8XHJcbiAgICAgICAgICAgIFtdKSxcclxuICAgIF07XHJcbiAgICBjb25zdCBtZW1vaXplZERlZmF1bHRWYWx1ZXMgPSB1c2VSZWYoZ2V0RGVmYXVsdFZhbHVlcygpKTtcclxuICAgIGNvbnN0IFtmaWVsZHMsIHNldEZpZWxkXSA9IHVzZVN0YXRlKG1hcElkcyhtZW1vaXplZERlZmF1bHRWYWx1ZXMuY3VycmVudCwga2V5TmFtZSkpO1xyXG4gICAgY29uc3QgYWxsRmllbGRzID0gdXNlUmVmKGZpZWxkcyk7XHJcbiAgICBjb25zdCByb290UGFyZW50TmFtZSA9IGdldEZpZWxkQXJyYXlQYXJlbnROYW1lKG5hbWUpO1xyXG4gICAgY29uc3QgZ2V0Q3VycmVudEZpZWxkc1ZhbHVlcyA9ICgpID0+IGdldChnZXRWYWx1ZXMoKSB8fCB7fSwgbmFtZSwgYWxsRmllbGRzLmN1cnJlbnQpLm1hcCgoaXRlbSwgaW5kZXgpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFsbEZpZWxkcy5jdXJyZW50W2luZGV4XSksIGl0ZW0pKSk7XHJcbiAgICBhbGxGaWVsZHMuY3VycmVudCA9IGZpZWxkcztcclxuICAgIGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LmFkZChuYW1lKTtcclxuICAgIGlmICghZ2V0KGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzLmN1cnJlbnQsIG5hbWUpICYmIHJvb3RQYXJlbnROYW1lKSB7XHJcbiAgICAgICAgc2V0KGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzLmN1cnJlbnQsIHJvb3RQYXJlbnROYW1lLCBnZXQoZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCByb290UGFyZW50TmFtZSkpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYXBwZW5kVmFsdWVXaXRoS2V5ID0gKHZhbHVlcykgPT4gdmFsdWVzLm1hcCgodmFsdWUpID0+IGFwcGVuZElkKHZhbHVlLCBrZXlOYW1lKSk7XHJcbiAgICBjb25zdCBzZXRGaWVsZEFuZFZhbGlkU3RhdGUgPSAoZmllbGRzVmFsdWVzKSA9PiB7XHJcbiAgICAgICAgc2V0RmllbGQoZmllbGRzVmFsdWVzKTtcclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzVmFsaWQgJiYgdmFsaWRhdGVTY2hlbWFJc1ZhbGlkKSB7XHJcbiAgICAgICAgICAgIHZhbGlkYXRlU2NoZW1hSXNWYWxpZCh7XHJcbiAgICAgICAgICAgICAgICBbbmFtZV06IGZpZWxkc1ZhbHVlcyxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHNob3VsZFJlbmRlckZpZWxkQXJyYXkgPSAoc2hvdWxkUmVuZGVyKSA9PiB7XHJcbiAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcyB8fFxyXG4gICAgICAgICAgICByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNEaXJ0eSB8fFxyXG4gICAgICAgICAgICByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNWYWxpZCkge1xyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW5kZXJXYXRjaGVkSW5wdXRzKG5hbWUpO1xyXG4gICAgICAgIHNob3VsZFJlbmRlciAmJiAhaXNXYXRjaEFsbFJlZi5jdXJyZW50ICYmIHJlUmVuZGVyKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVzZXRGaWVsZHMgPSAoZmxhZ09yRmllbGRzKSA9PiB7XHJcbiAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5pc0RpcnR5IHx8XHJcbiAgICAgICAgICAgIHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcykge1xyXG4gICAgICAgICAgICBpc0RpcnR5UmVmLmN1cnJlbnQgPVxyXG4gICAgICAgICAgICAgICAgaXNVbmRlZmluZWQoZmxhZ09yRmllbGRzKSB8fFxyXG4gICAgICAgICAgICAgICAgICAgICFkZWVwRXF1YWwoZmxhZ09yRmllbGRzLm1hcCgoX2EgPSB7fSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2IgPSBrZXlOYW1lLCBvbWl0dGVkID0gX2FbX2JdLCByZXN0ID0gX19yZXN0KF9hLCBbdHlwZW9mIF9iID09PSBcInN5bWJvbFwiID8gX2IgOiBfYiArIFwiXCJdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfSksIGdldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIG5hbWUsIFtdKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZpZWxkc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChpc01hdGNoRmllbGRBcnJheU5hbWUoa2V5LCBuYW1lKSAmJiBmaWVsZHNSZWYuY3VycmVudFtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVGaWVsZEV2ZW50TGlzdGVuZXIoZmllbGRzUmVmLmN1cnJlbnRba2V5XSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgY29uc3QgYXBwZW5kID0gKHZhbHVlLCBzaG91bGRGb2N1cyA9IHRydWUpID0+IHtcclxuICAgICAgICBzaG91bGRSZW5kZXIgPSBmYWxzZTtcclxuICAgICAgICBzZXRGaWVsZEFuZFZhbGlkU3RhdGUoW1xyXG4gICAgICAgICAgICAuLi5hbGxGaWVsZHMuY3VycmVudCxcclxuICAgICAgICAgICAgLi4uKGlzQXJyYXkodmFsdWUpXHJcbiAgICAgICAgICAgICAgICA/IGFwcGVuZFZhbHVlV2l0aEtleSh2YWx1ZSlcclxuICAgICAgICAgICAgICAgIDogW2FwcGVuZElkKHZhbHVlLCBrZXlOYW1lKV0pLFxyXG4gICAgICAgIF0pO1xyXG4gICAgICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMgfHxcclxuICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzRGlydHkpIHtcclxuICAgICAgICAgICAgc2V0KGRpcnR5RmllbGRzUmVmLmN1cnJlbnQsIG5hbWUsIFtcclxuICAgICAgICAgICAgICAgIC4uLihnZXQoZGlydHlGaWVsZHNSZWYuY3VycmVudCwgbmFtZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICBmaWxsRW1wdHlBcnJheShmaWVsZHMuc2xpY2UoMCwgMSkpKSxcclxuICAgICAgICAgICAgICAgIC4uLmZpbHRlckJvb2xlYW5BcnJheSh2YWx1ZSksXHJcbiAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICBpc0RpcnR5UmVmLmN1cnJlbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb2N1c0luZGV4UmVmLmN1cnJlbnQgPSBzaG91bGRGb2N1cyA/IGFsbEZpZWxkcy5jdXJyZW50Lmxlbmd0aCA6IC0xO1xyXG4gICAgICAgIHNob3VsZFJlbmRlckZpZWxkQXJyYXkoc2hvdWxkUmVuZGVyKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBwcmVwZW5kJDEgPSAodmFsdWUsIHNob3VsZEZvY3VzID0gdHJ1ZSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVtcHR5QXJyYXkgPSBmaWxsRW1wdHlBcnJheSh2YWx1ZSk7XHJcbiAgICAgICAgc2hvdWxkUmVuZGVyID0gZmFsc2U7XHJcbiAgICAgICAgc2V0RmllbGRBbmRWYWxpZFN0YXRlKHByZXBlbmQoZ2V0Q3VycmVudEZpZWxkc1ZhbHVlcygpLCBpc0FycmF5KHZhbHVlKSA/IGFwcGVuZFZhbHVlV2l0aEtleSh2YWx1ZSkgOiBbYXBwZW5kSWQodmFsdWUsIGtleU5hbWUpXSkpO1xyXG4gICAgICAgIHJlc2V0RmllbGRzKCk7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZ2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lKSkpIHtcclxuICAgICAgICAgICAgc2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lLCBwcmVwZW5kKGdldChlcnJvcnNSZWYuY3VycmVudCwgbmFtZSksIGVtcHR5QXJyYXkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC50b3VjaGVkICYmXHJcbiAgICAgICAgICAgIGdldCh0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHNldCh0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnQsIG5hbWUsIHByZXBlbmQoZ2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSksIGVtcHR5QXJyYXkpKTtcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcyB8fFxyXG4gICAgICAgICAgICByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNEaXJ0eSkge1xyXG4gICAgICAgICAgICBzZXQoZGlydHlGaWVsZHNSZWYuY3VycmVudCwgbmFtZSwgcHJlcGVuZChnZXQoZGlydHlGaWVsZHNSZWYuY3VycmVudCwgbmFtZSkgfHwgW10sIGZpbHRlckJvb2xlYW5BcnJheSh2YWx1ZSkpKTtcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2hvdWxkUmVuZGVyRmllbGRBcnJheShzaG91bGRSZW5kZXIpO1xyXG4gICAgICAgIGZvY3VzSW5kZXhSZWYuY3VycmVudCA9IHNob3VsZEZvY3VzID8gMCA6IC0xO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlbW92ZSA9IChpbmRleCkgPT4ge1xyXG4gICAgICAgIHNob3VsZFJlbmRlciA9IGZhbHNlO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0Q3VycmVudEZpZWxkc1ZhbHVlcygpO1xyXG4gICAgICAgIHNldEZpZWxkQW5kVmFsaWRTdGF0ZShyZW1vdmVBcnJheUF0KGZpZWxkVmFsdWVzLCBpbmRleCkpO1xyXG4gICAgICAgIHJlc2V0RmllbGRzKHJlbW92ZUFycmF5QXQoZmllbGRWYWx1ZXMsIGluZGV4KSk7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZ2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lKSkpIHtcclxuICAgICAgICAgICAgc2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lLCByZW1vdmVBcnJheUF0KGdldChlcnJvcnNSZWYuY3VycmVudCwgbmFtZSksIGluZGV4KSk7XHJcbiAgICAgICAgICAgIGlmICghdW5pcXVlKGdldChlcnJvcnNSZWYuY3VycmVudCwgbmFtZSwgW10pKS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIHVuc2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQgJiZcclxuICAgICAgICAgICAgZ2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSkpIHtcclxuICAgICAgICAgICAgc2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSwgcmVtb3ZlQXJyYXlBdChnZXQodG91Y2hlZEZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKSwgaW5kZXgpKTtcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMgfHxcclxuICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzRGlydHkpICYmXHJcbiAgICAgICAgICAgIGdldChkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKSkge1xyXG4gICAgICAgICAgICBzZXQoZGlydHlGaWVsZHNSZWYuY3VycmVudCwgbmFtZSwgcmVtb3ZlQXJyYXlBdChnZXQoZGlydHlGaWVsZHNSZWYuY3VycmVudCwgbmFtZSksIGluZGV4KSk7XHJcbiAgICAgICAgICAgIGlmICghdW5pcXVlKGdldChkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LCBuYW1lLCBbXSkpLmxlbmd0aCkge1xyXG4gICAgICAgICAgICAgICAgdW5zZXQoZGlydHlGaWVsZHNSZWYuY3VycmVudCwgbmFtZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5pc1ZhbGlkICYmICF2YWxpZGF0ZVNjaGVtYUlzVmFsaWQpIHtcclxuICAgICAgICAgICAgbGV0IGZpZWxkSW5kZXggPSAtMTtcclxuICAgICAgICAgICAgbGV0IGlzRm91bmQgPSBmYWxzZTtcclxuICAgICAgICAgICAgY29uc3QgaXNJbmRleFVuZGVmaW5lZCA9IGlzVW5kZWZpbmVkKGluZGV4KTtcclxuICAgICAgICAgICAgd2hpbGUgKGZpZWxkSW5kZXgrKyA8IGZpZWxkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGlzTGFzdCA9IGZpZWxkSW5kZXggPT09IGZpZWxkcy5sZW5ndGggLSAxO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50SW5kZXggPSAoaXNBcnJheShpbmRleCkgPyBpbmRleCA6IFtpbmRleF0pLmluZGV4T2YoZmllbGRJbmRleCkgPj0gMDtcclxuICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRJbmRleCB8fCBpc0luZGV4VW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNGb3VuZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoIWlzRm91bmQpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZpZWxkc1tmaWVsZEluZGV4XSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRGaWVsZE5hbWUgPSBgJHtuYW1lfVske2ZpZWxkSW5kZXh9XS4ke2tleX1gO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRJbmRleCB8fCBpc0xhc3QgfHwgaXNJbmRleFVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZEZpZWxkc1JlZi5jdXJyZW50LmRlbGV0ZShjdXJyZW50RmllbGROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudC5kZWxldGUoY3VycmVudEZpZWxkTmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c0ZpZWxkTmFtZSA9IGAke25hbWV9WyR7ZmllbGRJbmRleCAtIDF9XS4ke2tleX1gO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRGaWVsZHNSZWYuY3VycmVudC5oYXMoY3VycmVudEZpZWxkTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkRmllbGRzUmVmLmN1cnJlbnQuYWRkKHByZXZpb3VzRmllbGROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRzV2l0aFZhbGlkYXRpb25SZWYuY3VycmVudC5oYXMoY3VycmVudEZpZWxkTmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkc1dpdGhWYWxpZGF0aW9uUmVmLmN1cnJlbnQuYWRkKHByZXZpb3VzRmllbGROYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBzaG91bGRSZW5kZXJGaWVsZEFycmF5KHNob3VsZFJlbmRlcik7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaW5zZXJ0JDEgPSAoaW5kZXgsIHZhbHVlLCBzaG91bGRGb2N1cyA9IHRydWUpID0+IHtcclxuICAgICAgICBzaG91bGRSZW5kZXIgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBlbXB0eUFycmF5ID0gZmlsbEVtcHR5QXJyYXkodmFsdWUpO1xyXG4gICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0Q3VycmVudEZpZWxkc1ZhbHVlcygpO1xyXG4gICAgICAgIHNldEZpZWxkQW5kVmFsaWRTdGF0ZShpbnNlcnQoZmllbGRWYWx1ZXMsIGluZGV4LCBpc0FycmF5KHZhbHVlKSA/IGFwcGVuZFZhbHVlV2l0aEtleSh2YWx1ZSkgOiBbYXBwZW5kSWQodmFsdWUsIGtleU5hbWUpXSkpO1xyXG4gICAgICAgIHJlc2V0RmllbGRzKGluc2VydChmaWVsZFZhbHVlcywgaW5kZXgpKTtcclxuICAgICAgICBpZiAoaXNBcnJheShnZXQoZXJyb3JzUmVmLmN1cnJlbnQsIG5hbWUpKSkge1xyXG4gICAgICAgICAgICBzZXQoZXJyb3JzUmVmLmN1cnJlbnQsIG5hbWUsIGluc2VydChnZXQoZXJyb3JzUmVmLmN1cnJlbnQsIG5hbWUpLCBpbmRleCwgZW1wdHlBcnJheSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQgJiZcclxuICAgICAgICAgICAgZ2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSkpIHtcclxuICAgICAgICAgICAgc2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSwgaW5zZXJ0KGdldCh0b3VjaGVkRmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpLCBpbmRleCwgZW1wdHlBcnJheSkpO1xyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoKHJlYWRGb3JtU3RhdGVSZWYuY3VycmVudC5kaXJ0eUZpZWxkcyB8fFxyXG4gICAgICAgICAgICByZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuaXNEaXJ0eSkgJiZcclxuICAgICAgICAgICAgZ2V0KGRpcnR5RmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpKSB7XHJcbiAgICAgICAgICAgIHNldChkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LCBuYW1lLCBpbnNlcnQoZ2V0KGRpcnR5RmllbGRzUmVmLmN1cnJlbnQsIG5hbWUpLCBpbmRleCwgZmlsdGVyQm9vbGVhbkFycmF5KHZhbHVlKSkpO1xyXG4gICAgICAgICAgICBzaG91bGRSZW5kZXIgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzaG91bGRSZW5kZXJGaWVsZEFycmF5KHNob3VsZFJlbmRlcik7XHJcbiAgICAgICAgZm9jdXNJbmRleFJlZi5jdXJyZW50ID0gc2hvdWxkRm9jdXMgPyBpbmRleCA6IC0xO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHN3YXAgPSAoaW5kZXhBLCBpbmRleEIpID0+IHtcclxuICAgICAgICBzaG91bGRSZW5kZXIgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEN1cnJlbnRGaWVsZHNWYWx1ZXMoKTtcclxuICAgICAgICBzd2FwQXJyYXlBdChmaWVsZFZhbHVlcywgaW5kZXhBLCBpbmRleEIpO1xyXG4gICAgICAgIHJlc2V0RmllbGRzKGZpZWxkVmFsdWVzKTtcclxuICAgICAgICBzZXRGaWVsZEFuZFZhbGlkU3RhdGUoWy4uLmZpZWxkVmFsdWVzXSk7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZ2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lKSkpIHtcclxuICAgICAgICAgICAgc3dhcEFycmF5QXQoZ2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lKSwgaW5kZXhBLCBpbmRleEIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQgJiZcclxuICAgICAgICAgICAgZ2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSkpIHtcclxuICAgICAgICAgICAgc3dhcEFycmF5QXQoZ2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSksIGluZGV4QSwgaW5kZXhCKTtcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMgfHxcclxuICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzRGlydHkpICYmXHJcbiAgICAgICAgICAgIGdldChkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKSkge1xyXG4gICAgICAgICAgICBzd2FwQXJyYXlBdChnZXQoZGlydHlGaWVsZHNSZWYuY3VycmVudCwgbmFtZSksIGluZGV4QSwgaW5kZXhCKTtcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2hvdWxkUmVuZGVyRmllbGRBcnJheShzaG91bGRSZW5kZXIpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IG1vdmUgPSAoZnJvbSwgdG8pID0+IHtcclxuICAgICAgICBzaG91bGRSZW5kZXIgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IGdldEN1cnJlbnRGaWVsZHNWYWx1ZXMoKTtcclxuICAgICAgICBtb3ZlQXJyYXlBdChmaWVsZFZhbHVlcywgZnJvbSwgdG8pO1xyXG4gICAgICAgIHJlc2V0RmllbGRzKGZpZWxkVmFsdWVzKTtcclxuICAgICAgICBzZXRGaWVsZEFuZFZhbGlkU3RhdGUoWy4uLmZpZWxkVmFsdWVzXSk7XHJcbiAgICAgICAgaWYgKGlzQXJyYXkoZ2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lKSkpIHtcclxuICAgICAgICAgICAgbW92ZUFycmF5QXQoZ2V0KGVycm9yc1JlZi5jdXJyZW50LCBuYW1lKSwgZnJvbSwgdG8pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LnRvdWNoZWQgJiZcclxuICAgICAgICAgICAgZ2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSkpIHtcclxuICAgICAgICAgICAgbW92ZUFycmF5QXQoZ2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSksIGZyb20sIHRvKTtcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQuZGlydHlGaWVsZHMgfHxcclxuICAgICAgICAgICAgcmVhZEZvcm1TdGF0ZVJlZi5jdXJyZW50LmlzRGlydHkpICYmXHJcbiAgICAgICAgICAgIGdldChkaXJ0eUZpZWxkc1JlZi5jdXJyZW50LCBuYW1lKSkge1xyXG4gICAgICAgICAgICBtb3ZlQXJyYXlBdChnZXQoZGlydHlGaWVsZHNSZWYuY3VycmVudCwgbmFtZSksIGZyb20sIHRvKTtcclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2hvdWxkUmVuZGVyRmllbGRBcnJheShzaG91bGRSZW5kZXIpO1xyXG4gICAgfTtcclxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xyXG4gICAgICAgIHJlc2V0RmllbGRzKCk7XHJcbiAgICAgICAgbWVtb2l6ZWREZWZhdWx0VmFsdWVzLmN1cnJlbnQgPSBnZXREZWZhdWx0VmFsdWVzKCk7XHJcbiAgICAgICAgc2V0RmllbGQobWFwSWRzKG1lbW9pemVkRGVmYXVsdFZhbHVlcy5jdXJyZW50LCBrZXlOYW1lKSk7XHJcbiAgICB9O1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVzID0gZ2V0KGZpZWxkQXJyYXlEZWZhdWx0VmFsdWVzLmN1cnJlbnQsIG5hbWUpO1xyXG4gICAgICAgIGlmIChkZWZhdWx0VmFsdWVzICYmIGZpZWxkcy5sZW5ndGggPCBkZWZhdWx0VmFsdWVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWVzLnBvcCgpO1xyXG4gICAgICAgICAgICBzZXQoZmllbGRBcnJheURlZmF1bHRWYWx1ZXMuY3VycmVudCwgbmFtZSwgZGVmYXVsdFZhbHVlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpc1dhdGNoQWxsUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgcmVSZW5kZXIoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAod2F0Y2hGaWVsZHNSZWYpIHtcclxuICAgICAgICAgICAgbGV0IHNob3VsZFJlbmRlclVzZVdhdGNoID0gdHJ1ZTtcclxuICAgICAgICAgICAgZm9yIChjb25zdCB3YXRjaEZpZWxkIG9mIHdhdGNoRmllbGRzUmVmLmN1cnJlbnQpIHtcclxuICAgICAgICAgICAgICAgIGlmICh3YXRjaEZpZWxkLnN0YXJ0c1dpdGgobmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZVJlbmRlcigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlbmRlclVzZVdhdGNoID0gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgc2hvdWxkUmVuZGVyVXNlV2F0Y2ggJiYgcmVuZGVyV2F0Y2hlZElucHV0cyhuYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGZvY3VzSW5kZXhSZWYuY3VycmVudCA+IC0xKSB7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZpZWxkc1JlZi5jdXJyZW50KSB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1JlZi5jdXJyZW50W2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoYCR7bmFtZX1bJHtmb2N1c0luZGV4UmVmLmN1cnJlbnR9XWApICYmXHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQucmVmLmZvY3VzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZmllbGQucmVmLmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZm9jdXNJbmRleFJlZi5jdXJyZW50ID0gLTE7XHJcbiAgICB9LCBbXHJcbiAgICAgICAgZmllbGRzLFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgZmllbGRBcnJheURlZmF1bHRWYWx1ZXMsXHJcbiAgICAgICAgcmVSZW5kZXIsXHJcbiAgICAgICAgZmllbGRzUmVmLFxyXG4gICAgICAgIHdhdGNoRmllbGRzUmVmLFxyXG4gICAgICAgIGlzV2F0Y2hBbGxSZWYsXHJcbiAgICBdKTtcclxuICAgIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcmVzZXRGdW5jdGlvbnMgPSByZXNldEZpZWxkQXJyYXlGdW5jdGlvblJlZi5jdXJyZW50O1xyXG4gICAgICAgIHJlc2V0RnVuY3Rpb25zW25hbWVdID0gcmVzZXQ7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgcmVzZXRGaWVsZHMoKTtcclxuICAgICAgICAgICAgZGVsZXRlIHJlc2V0RnVuY3Rpb25zW25hbWVdO1xyXG4gICAgICAgICAgICBmaWVsZEFycmF5TmFtZXNSZWYuY3VycmVudC5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXHJcbiAgICB9LCBbXSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHN3YXA6IHVzZUNhbGxiYWNrKHN3YXAsIFtuYW1lXSksXHJcbiAgICAgICAgbW92ZTogdXNlQ2FsbGJhY2sobW92ZSwgW25hbWVdKSxcclxuICAgICAgICBwcmVwZW5kOiB1c2VDYWxsYmFjayhwcmVwZW5kJDEsIFtuYW1lXSksXHJcbiAgICAgICAgYXBwZW5kOiB1c2VDYWxsYmFjayhhcHBlbmQsIFtuYW1lXSksXHJcbiAgICAgICAgcmVtb3ZlOiB1c2VDYWxsYmFjayhyZW1vdmUsIFtmaWVsZHMsIG5hbWVdKSxcclxuICAgICAgICBpbnNlcnQ6IHVzZUNhbGxiYWNrKGluc2VydCQxLCBbbmFtZV0pLFxyXG4gICAgICAgIGZpZWxkcyxcclxuICAgIH07XHJcbn07XG5cbmZ1bmN0aW9uIHVzZVdhdGNoKHsgY29udHJvbCwgbmFtZSwgZGVmYXVsdFZhbHVlLCB9KSB7XHJcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcclxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICAgICAgaWYgKCFjb250cm9sICYmICFtZXRob2RzKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcign8J+TiyB1c2VXYXRjaCBpcyBtaXNzaW5nIGBjb250cm9sYCBwcm9wLicpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmFtZSA9PT0gJycpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCfwn5OLIHVzZVdhdGNoIGlzIG1pc3NpbmcgYG5hbWVgIGF0dHJpYnV0ZS4nKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCB7IHdhdGNoRmllbGRzSG9va1JlZiwgd2F0Y2hGaWVsZHNIb29rUmVuZGVyUmVmLCB3YXRjaEludGVybmFsLCBkZWZhdWx0VmFsdWVzUmVmLCB9ID0gY29udHJvbCB8fCBtZXRob2RzLmNvbnRyb2w7XHJcbiAgICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHVzZVN0YXRlKGlzVW5kZWZpbmVkKGRlZmF1bHRWYWx1ZSlcclxuICAgICAgICA/IGlzU3RyaW5nKG5hbWUpXHJcbiAgICAgICAgICAgID8gZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSlcclxuICAgICAgICAgICAgOiBpc0FycmF5KG5hbWUpXHJcbiAgICAgICAgICAgICAgICA/IG5hbWUucmVkdWNlKChwcmV2aW91cywgaW5wdXROYW1lKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2aW91cyksIHsgW2lucHV0TmFtZV06IGdldChkZWZhdWx0VmFsdWVzUmVmLmN1cnJlbnQsIGlucHV0TmFtZSkgfSkpLCB7fSlcclxuICAgICAgICAgICAgICAgIDogZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50XHJcbiAgICAgICAgOiBkZWZhdWx0VmFsdWUpO1xyXG4gICAgY29uc3QgaWRSZWYgPSB1c2VSZWYoKTtcclxuICAgIGNvbnN0IGRlZmF1bHRWYWx1ZVJlZiA9IHVzZVJlZihkZWZhdWx0VmFsdWUpO1xyXG4gICAgY29uc3QgdXBkYXRlV2F0Y2hWYWx1ZSA9IHVzZUNhbGxiYWNrKCgpID0+IHNldFZhbHVlKHdhdGNoSW50ZXJuYWwobmFtZSwgZGVmYXVsdFZhbHVlUmVmLmN1cnJlbnQsIGlkUmVmLmN1cnJlbnQpKSwgW3NldFZhbHVlLCB3YXRjaEludGVybmFsLCBkZWZhdWx0VmFsdWVSZWYsIG5hbWUsIGlkUmVmXSk7XHJcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlkID0gKGlkUmVmLmN1cnJlbnQgPSBnZW5lcmF0ZUlkKCkpO1xyXG4gICAgICAgIGNvbnN0IHdhdGNoRmllbGRzSG9va1JlbmRlciA9IHdhdGNoRmllbGRzSG9va1JlbmRlclJlZi5jdXJyZW50O1xyXG4gICAgICAgIGNvbnN0IHdhdGNoRmllbGRzSG9vayA9IHdhdGNoRmllbGRzSG9va1JlZi5jdXJyZW50O1xyXG4gICAgICAgIHdhdGNoRmllbGRzSG9va1tpZF0gPSBuZXcgU2V0KCk7XHJcbiAgICAgICAgd2F0Y2hGaWVsZHNIb29rUmVuZGVyW2lkXSA9IHVwZGF0ZVdhdGNoVmFsdWU7XHJcbiAgICAgICAgd2F0Y2hJbnRlcm5hbChuYW1lLCBkZWZhdWx0VmFsdWVSZWYuY3VycmVudCwgaWQpO1xyXG4gICAgICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB3YXRjaEZpZWxkc0hvb2tbaWRdO1xyXG4gICAgICAgICAgICBkZWxldGUgd2F0Y2hGaWVsZHNIb29rUmVuZGVyW2lkXTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW1xyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgdXBkYXRlV2F0Y2hWYWx1ZSxcclxuICAgICAgICB3YXRjaEZpZWxkc0hvb2tSZW5kZXJSZWYsXHJcbiAgICAgICAgd2F0Y2hGaWVsZHNIb29rUmVmLFxyXG4gICAgICAgIHdhdGNoSW50ZXJuYWwsXHJcbiAgICAgICAgZGVmYXVsdFZhbHVlUmVmLFxyXG4gICAgXSk7XHJcbiAgICByZXR1cm4gKGlzVW5kZWZpbmVkKHZhbHVlKSA/IGRlZmF1bHRWYWx1ZSA6IHZhbHVlKTtcclxufVxuXG52YXIgZ2V0SW5wdXRWYWx1ZSA9IChldmVudCkgPT4gaXNQcmltaXRpdmUoZXZlbnQpIHx8XHJcbiAgICAhaXNPYmplY3QoZXZlbnQudGFyZ2V0KSB8fFxyXG4gICAgKGlzT2JqZWN0KGV2ZW50LnRhcmdldCkgJiYgIWV2ZW50LnR5cGUpXHJcbiAgICA/IGV2ZW50XHJcbiAgICA6IGlzVW5kZWZpbmVkKGV2ZW50LnRhcmdldC52YWx1ZSlcclxuICAgICAgICA/IGV2ZW50LnRhcmdldC5jaGVja2VkXHJcbiAgICAgICAgOiBldmVudC50YXJnZXQudmFsdWU7XG5cbmNvbnN0IENvbnRyb2xsZXIgPSAoX2EpID0+IHtcclxuICAgIHZhciB7IG5hbWUsIHJ1bGVzLCBhcywgcmVuZGVyLCBkZWZhdWx0VmFsdWUsIGNvbnRyb2wsIG9uRm9jdXMgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJuYW1lXCIsIFwicnVsZXNcIiwgXCJhc1wiLCBcInJlbmRlclwiLCBcImRlZmF1bHRWYWx1ZVwiLCBcImNvbnRyb2xcIiwgXCJvbkZvY3VzXCJdKTtcclxuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWNvbnRyb2wgJiYgIW1ldGhvZHMpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ/Cfk4sgQ29udHJvbGxlciBpcyBtaXNzaW5nIGBjb250cm9sYCBwcm9wLicpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgeyBkZWZhdWx0VmFsdWVzUmVmLCBzZXRWYWx1ZSwgcmVnaXN0ZXIsIHVucmVnaXN0ZXIsIHRyaWdnZXIsIG1vZGUsIHJlVmFsaWRhdGVNb2RlOiB7IGlzUmVWYWxpZGF0ZU9uQmx1ciwgaXNSZVZhbGlkYXRlT25DaGFuZ2UgfSwgaXNTdWJtaXR0ZWRSZWYsIHRvdWNoZWRGaWVsZHNSZWYsIHJlYWRGb3JtU3RhdGVSZWYsIHJlUmVuZGVyLCBmaWVsZHNSZWYsIGZpZWxkQXJyYXlOYW1lc1JlZiwgdW5tb3VudEZpZWxkc1N0YXRlUmVmLCB9ID0gY29udHJvbCB8fCBtZXRob2RzLmNvbnRyb2w7XHJcbiAgICBjb25zdCBpc05vdEZpZWxkQXJyYXkgPSAhaXNOYW1lSW5GaWVsZEFycmF5KGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LCBuYW1lKTtcclxuICAgIGNvbnN0IGdldEluaXRpYWxWYWx1ZSA9ICgpID0+ICFpc1VuZGVmaW5lZChnZXQodW5tb3VudEZpZWxkc1N0YXRlUmVmLmN1cnJlbnQsIG5hbWUpKSAmJiBpc05vdEZpZWxkQXJyYXlcclxuICAgICAgICA/IHVubW91bnRGaWVsZHNTdGF0ZVJlZi5jdXJyZW50W25hbWVdXHJcbiAgICAgICAgOiBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpXHJcbiAgICAgICAgICAgID8gZ2V0KGRlZmF1bHRWYWx1ZXNSZWYuY3VycmVudCwgbmFtZSlcclxuICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWU7XHJcbiAgICBjb25zdCBbdmFsdWUsIHNldElucHV0U3RhdGVWYWx1ZV0gPSB1c2VTdGF0ZShnZXRJbml0aWFsVmFsdWUoKSk7XHJcbiAgICBjb25zdCB2YWx1ZVJlZiA9IHVzZVJlZih2YWx1ZSk7XHJcbiAgICBjb25zdCBvbkZvY3VzUmVmID0gdXNlUmVmKG9uRm9jdXMpO1xyXG4gICAgY29uc3QgaXNTdWJtaXR0ZWQgPSBpc1N1Ym1pdHRlZFJlZi5jdXJyZW50O1xyXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcclxuICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2Fybign8J+TiyBDb250cm9sbGVyIGBkZWZhdWx0VmFsdWVgIG9yIHVzZUZvcm0gYGRlZmF1bHRWYWx1ZXNgIGlzIG1pc3NpbmcuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhcyAmJiByZW5kZXIpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCfwn5OLIFNob3VsZCB1c2UgZWl0aGVyIGBhc2Agb3IgYHJlbmRlcmAgcHJvcC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFpc05vdEZpZWxkQXJyYXkgJiYgaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ/Cfk4sgQ29udHJvbGxlciBpcyBtaXNzaW5nIGBkZWZhdWx0VmFsdWVgIHByb3Agd2hlbiB1c2luZyBgdXNlRmllbGRBcnJheWAuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgY29uc3Qgc2hvdWxkVmFsaWRhdGUgPSAoaXNCbHVyRXZlbnQpID0+ICFza2lwVmFsaWRhdGlvbihPYmplY3QuYXNzaWduKHsgaXNCbHVyRXZlbnQsXHJcbiAgICAgICAgaXNSZVZhbGlkYXRlT25CbHVyLFxyXG4gICAgICAgIGlzUmVWYWxpZGF0ZU9uQ2hhbmdlLFxyXG4gICAgICAgIGlzU3VibWl0dGVkIH0sIG1vZGUpKTtcclxuICAgIGNvbnN0IGNvbW1vblRhc2sgPSAoW2V2ZW50XSkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBnZXRJbnB1dFZhbHVlKGV2ZW50KTtcclxuICAgICAgICBzZXRJbnB1dFN0YXRlVmFsdWUoZGF0YSk7XHJcbiAgICAgICAgdmFsdWVSZWYuY3VycmVudCA9IGRhdGE7XHJcbiAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgcmVnaXN0ZXJGaWVsZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcclxuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhbmFtZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKCfwn5OLIEZpZWxkIGlzIG1pc3NpbmcgYG5hbWVgIHByb3AuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChmaWVsZHNSZWYuY3VycmVudFtuYW1lXSkge1xyXG4gICAgICAgICAgICBmaWVsZHNSZWYuY3VycmVudFtuYW1lXSA9IE9iamVjdC5hc3NpZ24oeyByZWY6IGZpZWxkc1JlZi5jdXJyZW50W25hbWVdLnJlZiB9LCBydWxlcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZWdpc3RlcihPYmplY3QuZGVmaW5lUHJvcGVydHkoeyBuYW1lLCBmb2N1czogb25Gb2N1c1JlZi5jdXJyZW50IH0sIFZBTFVFLCB7XHJcbiAgICAgICAgICAgICAgICBzZXQoZGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHNldElucHV0U3RhdGVWYWx1ZShkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB2YWx1ZVJlZi5jdXJyZW50ID0gZGF0YTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBnZXQoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlUmVmLmN1cnJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9KSwgcnVsZXMpO1xyXG4gICAgICAgICAgICBpZiAoaXNOb3RGaWVsZEFycmF5ICYmICFnZXQoZGVmYXVsdFZhbHVlc1JlZi5jdXJyZW50LCBuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgc2V0SW5wdXRTdGF0ZVZhbHVlKGdldEluaXRpYWxWYWx1ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0sIFtmaWVsZHNSZWYsIHJ1bGVzLCBuYW1lLCBvbkZvY3VzUmVmLCByZWdpc3Rlcl0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+ICgpID0+IHtcclxuICAgICAgICAhaXNOYW1lSW5GaWVsZEFycmF5KGZpZWxkQXJyYXlOYW1lc1JlZi5jdXJyZW50LCBuYW1lKSAmJiB1bnJlZ2lzdGVyKG5hbWUpO1xyXG4gICAgfSwgW3VucmVnaXN0ZXIsIG5hbWUsIGZpZWxkQXJyYXlOYW1lc1JlZl0pO1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICByZWdpc3RlckZpZWxkKCk7XHJcbiAgICB9LCBbcmVnaXN0ZXJGaWVsZF0pO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xyXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgICAgICBpZiAoIWZpZWxkc1JlZi5jdXJyZW50W25hbWVdKSB7XHJcbiAgICAgICAgICAgIHJlZ2lzdGVyRmllbGQoKTtcclxuICAgICAgICAgICAgaWYgKGlzTm90RmllbGRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgc2V0SW5wdXRTdGF0ZVZhbHVlKGdldEluaXRpYWxWYWx1ZSgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgY29uc3Qgb25CbHVyID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChyZWFkRm9ybVN0YXRlUmVmLmN1cnJlbnQudG91Y2hlZCAmJlxyXG4gICAgICAgICAgICAhZ2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSkpIHtcclxuICAgICAgICAgICAgc2V0KHRvdWNoZWRGaWVsZHNSZWYuY3VycmVudCwgbmFtZSwgdHJ1ZSk7XHJcbiAgICAgICAgICAgIHJlUmVuZGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzaG91bGRWYWxpZGF0ZSh0cnVlKSkge1xyXG4gICAgICAgICAgICB0cmlnZ2VyKG5hbWUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBjb25zdCBvbkNoYW5nZSA9ICguLi5ldmVudCkgPT4gc2V0VmFsdWUobmFtZSwgY29tbW9uVGFzayhldmVudCksIHtcclxuICAgICAgICBzaG91bGRWYWxpZGF0ZTogc2hvdWxkVmFsaWRhdGUoKSxcclxuICAgICAgICBzaG91bGREaXJ0eTogdHJ1ZSxcclxuICAgIH0pO1xyXG4gICAgY29uc3QgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCB7IG9uQ2hhbmdlLFxyXG4gICAgICAgIG9uQmx1cixcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHZhbHVlIH0pO1xyXG4gICAgcmV0dXJuIGFzXHJcbiAgICAgICAgPyBpc1ZhbGlkRWxlbWVudChhcylcclxuICAgICAgICAgICAgPyBjbG9uZUVsZW1lbnQoYXMsIHByb3BzKVxyXG4gICAgICAgICAgICA6IGNyZWF0ZUVsZW1lbnQoYXMsIHByb3BzKVxyXG4gICAgICAgIDogcmVuZGVyXHJcbiAgICAgICAgICAgID8gcmVuZGVyKHtcclxuICAgICAgICAgICAgICAgIG9uQ2hhbmdlLFxyXG4gICAgICAgICAgICAgICAgb25CbHVyLFxyXG4gICAgICAgICAgICAgICAgdmFsdWUsXHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIDogbnVsbDtcclxufTtcblxuZXhwb3J0IHsgQ29udHJvbGxlciwgRm9ybVByb3ZpZGVyLCBhcHBlbmRFcnJvcnMsIGdldCwgdHJhbnNmb3JtVG9OZXN0T2JqZWN0LCB1c2VGaWVsZEFycmF5LCB1c2VGb3JtLCB1c2VGb3JtQ29udGV4dCwgdXNlV2F0Y2ggfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react-hook-form/dist/index.esm.js\n");

/***/ }),

/***/ "./src/components/pages/SingIn.js":
/*!****************************************!*\
  !*** ./src/components/pages/SingIn.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SignIn; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _material_ui_core_Avatar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @material-ui/core/Avatar */ \"./node_modules/@material-ui/core/esm/Avatar/index.js\");\n/* harmony import */ var _material_ui_core_Button__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @material-ui/core/Button */ \"./node_modules/@material-ui/core/esm/Button/index.js\");\n/* harmony import */ var _material_ui_core_CssBaseline__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @material-ui/core/CssBaseline */ \"./node_modules/@material-ui/core/esm/CssBaseline/index.js\");\n/* harmony import */ var _material_ui_core_TextField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @material-ui/core/TextField */ \"./node_modules/@material-ui/core/esm/TextField/index.js\");\n/* harmony import */ var _material_ui_core_FormControlLabel__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @material-ui/core/FormControlLabel */ \"./node_modules/@material-ui/core/esm/FormControlLabel/index.js\");\n/* harmony import */ var _material_ui_core_Checkbox__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @material-ui/core/Checkbox */ \"./node_modules/@material-ui/core/esm/Checkbox/index.js\");\n/* harmony import */ var _material_ui_core_Link__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @material-ui/core/Link */ \"./node_modules/@material-ui/core/esm/Link/index.js\");\n/* harmony import */ var _material_ui_core_Grid__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @material-ui/core/Grid */ \"./node_modules/@material-ui/core/esm/Grid/index.js\");\n/* harmony import */ var _material_ui_core_Box__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @material-ui/core/Box */ \"./node_modules/@material-ui/core/esm/Box/index.js\");\n/* harmony import */ var _material_ui_icons_LockOutlined__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @material-ui/icons/LockOutlined */ \"./node_modules/@material-ui/icons/LockOutlined.js\");\n/* harmony import */ var _material_ui_icons_LockOutlined__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_material_ui_icons_LockOutlined__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @material-ui/core/Typography */ \"./node_modules/@material-ui/core/esm/Typography/index.js\");\n/* harmony import */ var _material_ui_core_styles__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @material-ui/core/styles */ \"./node_modules/@material-ui/core/esm/styles/index.js\");\n/* harmony import */ var _material_ui_core_Container__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @material-ui/core/Container */ \"./node_modules/@material-ui/core/esm/Container/index.js\");\n/* harmony import */ var _hooks_useCheckAuth__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../../hooks/useCheckAuth */ \"./src/hooks/useCheckAuth.js\");\n/* harmony import */ var react_router_dom__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! react-router-dom */ \"./node_modules/react-router-dom/esm/react-router-dom.js\");\n/* harmony import */ var react_hook_form__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! react-hook-form */ \"./node_modules/react-hook-form/dist/index.esm.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction Copyright() {\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n    variant: \"body2\",\n    color: \"textSecondary\",\n    align: \"center\"\n  }, 'Copyright © ', react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Link__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n    color: \"inherit\",\n    href: \"https://material-ui.com/\"\n  }, \"Your Website\"), ' ', new Date().getFullYear(), '.');\n}\n\nvar useStyles = Object(_material_ui_core_styles__WEBPACK_IMPORTED_MODULE_12__[\"makeStyles\"])(function (theme) {\n  return {\n    paper: {\n      marginTop: theme.spacing(8),\n      display: 'flex',\n      flexDirection: 'column',\n      alignItems: 'center'\n    },\n    avatar: {\n      margin: theme.spacing(1),\n      backgroundColor: theme.palette.secondary.main\n    },\n    form: {\n      width: '100%',\n      // Fix IE 11 issue.\n      marginTop: theme.spacing(1)\n    },\n    submit: {\n      margin: theme.spacing(3, 0, 2)\n    }\n  };\n});\nfunction SignIn() {\n  var classes = useStyles();\n  var authenticated = Object(_hooks_useCheckAuth__WEBPACK_IMPORTED_MODULE_14__[\"default\"])();\n  var history = Object(react_router_dom__WEBPACK_IMPORTED_MODULE_15__[\"useHistory\"])();\n\n  var _useForm = Object(react_hook_form__WEBPACK_IMPORTED_MODULE_16__[\"useForm\"])(),\n      register = _useForm.register,\n      handleSubmit = _useForm.handleSubmit,\n      errors = _useForm.errors;\n\n  Object(react__WEBPACK_IMPORTED_MODULE_0__[\"useEffect\"])(function () {\n    if (!!authenticated) history.push('/dashboard');\n  }, []);\n  return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Container__WEBPACK_IMPORTED_MODULE_13__[\"default\"], {\n    component: \"main\",\n    maxWidth: \"xs\"\n  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_CssBaseline__WEBPACK_IMPORTED_MODULE_3__[\"default\"], null), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", {\n    className: classes.paper\n  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Avatar__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n    className: classes.avatar\n  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_icons_LockOutlined__WEBPACK_IMPORTED_MODULE_10___default.a, null)), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Typography__WEBPACK_IMPORTED_MODULE_11__[\"default\"], {\n    component: \"h1\",\n    variant: \"h5\"\n  }, \"You must enter passcode to enter to dashboard\"), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"form\", {\n    className: classes.form,\n    noValidate: true\n  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_TextField__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {\n    variant: \"outlined\",\n    margin: \"normal\",\n    required: true,\n    fullWidth: true,\n    name: \"password\",\n    label: \"Password\",\n    type: \"password\",\n    id: \"password\",\n    autoComplete: \"current-password\",\n    inputRef: register({\n      required: true\n    })\n  }), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Button__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n    type: \"submit\",\n    fullWidth: true,\n    variant: \"contained\",\n    color: \"primary\",\n    className: classes.submit\n  }, \"Sign In\"))), react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_material_ui_core_Box__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n    mt: 8\n  }, react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(Copyright, null)));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9wYWdlcy9TaW5nSW4uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY29tcG9uZW50cy9wYWdlcy9TaW5nSW4uanM/ZjEzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgQXZhdGFyIGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL0F2YXRhcic7XHJcbmltcG9ydCBCdXR0b24gZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvQnV0dG9uJztcclxuaW1wb3J0IENzc0Jhc2VsaW5lIGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL0Nzc0Jhc2VsaW5lJztcclxuaW1wb3J0IFRleHRGaWVsZCBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9UZXh0RmllbGQnO1xyXG5pbXBvcnQgRm9ybUNvbnRyb2xMYWJlbCBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9Gb3JtQ29udHJvbExhYmVsJztcclxuaW1wb3J0IENoZWNrYm94IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL0NoZWNrYm94JztcclxuaW1wb3J0IExpbmsgZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvTGluayc7XHJcbmltcG9ydCBHcmlkIGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL0dyaWQnO1xyXG5pbXBvcnQgQm94IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL0JveCc7XHJcbmltcG9ydCBMb2NrT3V0bGluZWRJY29uIGZyb20gJ0BtYXRlcmlhbC11aS9pY29ucy9Mb2NrT3V0bGluZWQnO1xyXG5pbXBvcnQgVHlwb2dyYXBoeSBmcm9tICdAbWF0ZXJpYWwtdWkvY29yZS9UeXBvZ3JhcGh5JztcclxuaW1wb3J0IHsgbWFrZVN0eWxlcyB9IGZyb20gJ0BtYXRlcmlhbC11aS9jb3JlL3N0eWxlcyc7XHJcbmltcG9ydCBDb250YWluZXIgZnJvbSAnQG1hdGVyaWFsLXVpL2NvcmUvQ29udGFpbmVyJztcclxuaW1wb3J0IHVzZUNoZWNrQXV0aCBmcm9tICcuLi8uLi9ob29rcy91c2VDaGVja0F1dGgnXHJcbmltcG9ydCB7IHVzZUhpc3RvcnkgfSBmcm9tICdyZWFjdC1yb3V0ZXItZG9tJztcclxuaW1wb3J0IHsgdXNlRm9ybSB9IGZyb20gJ3JlYWN0LWhvb2stZm9ybSdcclxuXHJcbmZ1bmN0aW9uIENvcHlyaWdodCgpIHtcclxuICByZXR1cm4gKFxyXG4gICAgPFR5cG9ncmFwaHkgdmFyaWFudD1cImJvZHkyXCIgY29sb3I9XCJ0ZXh0U2Vjb25kYXJ5XCIgYWxpZ249XCJjZW50ZXJcIj5cclxuICAgICAgeydDb3B5cmlnaHQgwqkgJ31cclxuICAgICAgPExpbmsgY29sb3I9XCJpbmhlcml0XCIgaHJlZj1cImh0dHBzOi8vbWF0ZXJpYWwtdWkuY29tL1wiPlxyXG4gICAgICAgIFlvdXIgV2Vic2l0ZVxyXG4gICAgICA8L0xpbms+eycgJ31cclxuICAgICAge25ldyBEYXRlKCkuZ2V0RnVsbFllYXIoKX1cclxuICAgICAgeycuJ31cclxuICAgIDwvVHlwb2dyYXBoeT5cclxuICApO1xyXG59XHJcblxyXG5jb25zdCB1c2VTdHlsZXMgPSBtYWtlU3R5bGVzKCh0aGVtZSkgPT4gKHtcclxuICBwYXBlcjoge1xyXG4gICAgbWFyZ2luVG9wOiB0aGVtZS5zcGFjaW5nKDgpLFxyXG4gICAgZGlzcGxheTogJ2ZsZXgnLFxyXG4gICAgZmxleERpcmVjdGlvbjogJ2NvbHVtbicsXHJcbiAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcclxuICB9LFxyXG4gIGF2YXRhcjoge1xyXG4gICAgbWFyZ2luOiB0aGVtZS5zcGFjaW5nKDEpLFxyXG4gICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLnNlY29uZGFyeS5tYWluLFxyXG4gIH0sXHJcbiAgZm9ybToge1xyXG4gICAgd2lkdGg6ICcxMDAlJywgLy8gRml4IElFIDExIGlzc3VlLlxyXG4gICAgbWFyZ2luVG9wOiB0aGVtZS5zcGFjaW5nKDEpLFxyXG4gIH0sXHJcbiAgc3VibWl0OiB7XHJcbiAgICBtYXJnaW46IHRoZW1lLnNwYWNpbmcoMywgMCwgMiksXHJcbiAgfSxcclxufSkpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2lnbkluKCkge1xyXG4gIGNvbnN0IGNsYXNzZXMgPSB1c2VTdHlsZXMoKTtcclxuICBjb25zdCBhdXRoZW50aWNhdGVkID0gdXNlQ2hlY2tBdXRoKClcclxuICBjb25zdCBoaXN0b3J5ID0gdXNlSGlzdG9yeSgpXHJcbiAgY29uc3QgeyByZWdpc3RlciwgaGFuZGxlU3VibWl0LCBlcnJvcnMgfSA9IHVzZUZvcm0oKVxyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgaWYoISFhdXRoZW50aWNhdGVkKVxyXG4gICAgICBoaXN0b3J5LnB1c2goJy9kYXNoYm9hcmQnKVxyXG4gIH0sIFtdKVxyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPENvbnRhaW5lciBjb21wb25lbnQ9XCJtYWluXCIgbWF4V2lkdGg9XCJ4c1wiPlxyXG4gICAgICA8Q3NzQmFzZWxpbmUgLz5cclxuICAgICAgPGRpdiBjbGFzc05hbWU9e2NsYXNzZXMucGFwZXJ9PlxyXG4gICAgICAgIDxBdmF0YXIgY2xhc3NOYW1lPXtjbGFzc2VzLmF2YXRhcn0+XHJcbiAgICAgICAgICA8TG9ja091dGxpbmVkSWNvbiAvPlxyXG4gICAgICAgIDwvQXZhdGFyPlxyXG4gICAgICAgIDxUeXBvZ3JhcGh5IGNvbXBvbmVudD1cImgxXCIgdmFyaWFudD1cImg1XCI+XHJcbiAgICAgICAgICBZb3UgbXVzdCBlbnRlciBwYXNzY29kZSB0byBlbnRlciB0byBkYXNoYm9hcmRcclxuICAgICAgICA8L1R5cG9ncmFwaHk+XHJcbiAgICAgICAgPGZvcm0gY2xhc3NOYW1lPXtjbGFzc2VzLmZvcm19IG5vVmFsaWRhdGU+XHJcbiAgICAgICAgICA8VGV4dEZpZWxkXHJcbiAgICAgICAgICAgIHZhcmlhbnQ9XCJvdXRsaW5lZFwiXHJcbiAgICAgICAgICAgIG1hcmdpbj1cIm5vcm1hbFwiXHJcbiAgICAgICAgICAgIHJlcXVpcmVkXHJcbiAgICAgICAgICAgIGZ1bGxXaWR0aFxyXG4gICAgICAgICAgICBuYW1lPVwicGFzc3dvcmRcIlxyXG4gICAgICAgICAgICBsYWJlbD1cIlBhc3N3b3JkXCJcclxuICAgICAgICAgICAgdHlwZT1cInBhc3N3b3JkXCJcclxuICAgICAgICAgICAgaWQ9XCJwYXNzd29yZFwiXHJcbiAgICAgICAgICAgIGF1dG9Db21wbGV0ZT1cImN1cnJlbnQtcGFzc3dvcmRcIlxyXG4gICAgICAgICAgICBpbnB1dFJlZj17cmVnaXN0ZXIoeyByZXF1aXJlZDogdHJ1ZSB9KX1cclxuICAgICAgICAgIC8+XHJcbiAgICAgICAgICA8QnV0dG9uXHJcbiAgICAgICAgICAgIHR5cGU9XCJzdWJtaXRcIlxyXG4gICAgICAgICAgICBmdWxsV2lkdGhcclxuICAgICAgICAgICAgdmFyaWFudD1cImNvbnRhaW5lZFwiXHJcbiAgICAgICAgICAgIGNvbG9yPVwicHJpbWFyeVwiXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZT17Y2xhc3Nlcy5zdWJtaXR9XHJcbiAgICAgICAgICA+XHJcbiAgICAgICAgICAgIFNpZ24gSW5cclxuICAgICAgICAgIDwvQnV0dG9uPlxyXG4gICAgICAgIDwvZm9ybT5cclxuICAgICAgPC9kaXY+XHJcbiAgICAgIDxCb3ggbXQ9ezh9PlxyXG4gICAgICAgIDxDb3B5cmlnaHQgLz5cclxuICAgICAgPC9Cb3g+XHJcbiAgICA8L0NvbnRhaW5lcj5cclxuICApO1xyXG59XHJcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBRUE7QUFBQTtBQUFBO0FBT0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFBQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBREE7QUFmQTtBQUFBO0FBb0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBS0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUFBO0FBQUE7QUFFQTtBQUFBO0FBQ0E7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUdBO0FBQUE7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQVZBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBV0E7QUFBQTtBQUtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/pages/SingIn.js\n");

/***/ })

})